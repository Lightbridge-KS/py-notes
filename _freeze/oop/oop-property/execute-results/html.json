{
  "hash": "cd08e76a5ab31d6b2d8af658b4f37ed9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"OOP Property\"\n---\n\n\n\n\nUsing `@property` in Python provides several key benefits over directly accessing class attributes. These benefits are centered around encapsulation, flexibility, and maintainability.\n\n\n## `Book` Example\n\n### Encapsulation and Control\n\nWith `@property`, you can control how attributes are accessed and modified without exposing the underlying implementation. This allows for:\n\n- **Validation**: Add logic to validate or transform data before returning or setting values.\n- **Read-only Attributes**: Mark certain attributes as read-only by providing only a getter.\n- **Future-proofing**: You can later modify the property logic (e.g., calculate a value on the fly) without changing how it's accessed.\n\n::: {#2e0e95d1 .cell execution_count=1}\n``` {.python .cell-code}\nclass Book:\n    def __init__(self, title, last, first):\n        self._title = title\n\n    @property\n    def title(self):\n        # Add validation or transformation logic\n        return self._title.upper()  # Automatically return uppercase\n\nbook = Book(\"The Great Gatsby\", \"Fitzgerald\", \"F. Scott\")\nprint(book.title)  # Output: THE GREAT GATSBY\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTHE GREAT GATSBY\n```\n:::\n:::\n\n\n### Encapsulation of Implementation Details\n\nBy using `@property`, you abstract away the implementation details from the user of the class. The user does not need to know whether the value is stored as a private variable, computed dynamically, or retrieved from another source.\n\n::: {#d7d6164f .cell execution_count=2}\n``` {.python .cell-code}\nclass Book:\n    def __init__(self, title):\n        self._raw_title = title\n\n    @property\n    def title(self):\n        return self._raw_title.title()  # Dynamically format\n\n    @title.setter\n    def title(self, value):\n        self._raw_title = value.strip()  # Clean user input\n\nbook = Book(\" the great gatsby \")\nprint(book.title)  # Output: The Great Gatsby\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n The Great Gatsby \n```\n:::\n:::\n\n\nIf you accessed `self._raw_title` directly, you'd lose the automatic formatting and validation benefits.\n\n---\n\n### Compatibility and API Stability\n\nWhen designing a public-facing API, using properties allows you to ensure backward compatibility if the implementation changes. \n\nFor example:\n\n- Initially, `title` could be a stored attribute.\n- Later, you might calculate `title` dynamically based on other attributes, and no user code would need to change.\n\n::: {#398ae961 .cell execution_count=3}\n``` {.python .cell-code}\nclass Book:\n    def __init__(self, title, subtitle):\n        self._title = title\n        self._subtitle = subtitle\n\n    @property\n    def title(self):\n        return f\"{self._title}: {self._subtitle}\"  # Dynamically computed\n\nbook = Book(\"The Great Gatsby\", \"A Classic Novel\")\nprint(book.title)  # Output: The Great Gatsby: A Classic Novel\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe Great Gatsby: A Classic Novel\n```\n:::\n:::\n\n\n---\n\n### Cleaner Syntax Compared to Getters/Setters\n\nUsing `@property` is cleaner and more Pythonic compared to Java-style explicit getter and setter methods.\n\n\n::: {.panel-tabset}\n#### **Without `@property`:**\n\n::: {#8722a6cb .cell execution_count=4}\n``` {.python .cell-code}\nclass Book:\n    def __init__(self, title):\n        self._title = title\n\n    def get_title(self):\n        return self._title\n\n    def set_title(self, value):\n        self._title = value\n\nbook = Book(\"The Great Gatsby\")\nprint(book.get_title())  # Verbose\nbook.set_title(\"New Title\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe Great Gatsby\n```\n:::\n:::\n\n\n#### **With `@property`:**\n\n::: {#d8c80b81 .cell execution_count=5}\n``` {.python .cell-code}\nclass Book:\n    def __init__(self, title):\n        self._title = title\n\n    @property\n    def title(self):\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        self._title = value\n\nbook = Book(\"The Great Gatsby\")\nprint(book.title)  # Cleaner syntax\nbook.title = \"New Title\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe Great Gatsby\n```\n:::\n:::\n\n\n:::\n\n---\n\n### Enhanced Readability and Usage\n\nThe use of properties makes code more readable and intuitive. It allows attribute-like access (`obj.title`) while still enabling additional logic under the hood.\n\n---\n\n### Summary Table\n\n| **Aspect**                  | **Direct Attribute Access**                     | **Using `@property`**                              |\n|-----------------------------|------------------------------------------------|--------------------------------------------------|\n| **Encapsulation**            | No control over attribute access or modification | Enables validation, transformation, or computed values |\n| **Read-only Attributes**     | Not possible                                   | Possible by defining only a getter               |\n| **API Stability**            | Changes in implementation break user code      | Implementation changes don't affect the interface |\n| **Readability**              | Less readable (e.g., `get_title()`)            | More readable (`book.title`)                     |\n| **Validation or Logic**      | Must be implemented separately                 | Can be embedded in getter/setter                 |\n\nUsing `@property` is particularly useful for creating robust, maintainable, and user-friendly classes in Python.\n\n\n## `Circle` Example\n\n::: {#6222cf87 .cell execution_count=6}\n``` {.python .cell-code}\nfrom math import pi\n```\n:::\n\n\nAnother significant benefit of using `@property` in this example is **\"on-demand calculation of derived attributes\"**. Here's how this principle applies in the `Circle` class:\n\nThe `@property` decorator allows you to define **calculated attributes** like `circumference` and `area` as properties, rather than storing them as separate attributes. This approach has several advantages:\n\n---\n\n### No Need to Manually Update Derived Attributes\n\n- If the `radius` changes, the `circumference` and `area` will always reflect the latest value without requiring manual updates.\n- This avoids the risk of inconsistency between the `radius` and the derived values.\n\n::: {.panel-tabset}\n#### without `@property`\n\n::: {#450039aa .cell execution_count=7}\n``` {.python .cell-code}\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n        self._circumference = 2 * pi * radius  # Manually set\n        self._area = pi * radius ** 2          # Manually set\n\n    def update_radius(self, radius):\n        self._radius = radius\n        self._circumference = 2 * pi * radius  # Must update manually\n        self._area = pi * radius ** 2          # Must update manually\n\ncircle = Circle(10)\ncircle.update_radius(20)\nprint(circle._circumference)  # Correct only if manually updated\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n125.66370614359172\n```\n:::\n:::\n\n\n#### with `@property`\n\n::: {#4ecb1296 .cell execution_count=8}\n``` {.python .cell-code}\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def circumference(self):\n        return 2 * pi * self._radius  # Always up-to-date\n\n    @property\n    def area(self):\n        return pi * self._radius ** 2  # Always up-to-date\n\ncircle = Circle(10)\nprint(circle.circumference)  # Automatically correct\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n62.83185307179586\n```\n:::\n:::\n\n\n:::\n\n\n- The `@property` approach ensures the derived values (`circumference` and `area`) are always consistent with `radius`, eliminating the need to manually synchronize them.\n\n---\n\n### Improved Memory Efficiency\n\n- The `circumference` and `area` are not stored as separate attributes, reducing memory usage.\n- These values are calculated only when accessed, saving memory for cases where these properties are not needed.\n\n::: {#cc5df746 .cell execution_count=9}\n``` {.python .cell-code}\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n\n    @property\n    def circumference(self):\n        return 2 * pi * self._radius\n\n    @property\n    def area(self):\n        return pi * self._radius ** 2\n```\n:::\n\n\n- The above implementation doesn't store `_circumference` or `_area` in memory but computes them dynamically.\n\n---\n\n### Readability and Intuitiveness\n\n\n- The use of `@property` makes the code intuitive to use, as `circumference` and `area` behave like attributes even though they are computed properties.\n\n::: {#2997e6cc .cell execution_count=10}\n``` {.python .cell-code}\ncircle = Circle(5)\nprint(circle.circumference)  # Easy-to-read syntax\nprint(circle.area)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n31.41592653589793\n78.53981633974483\n```\n:::\n:::\n\n\nCompared to manually calling methods for derived values:\n\n\n```python\ncircle.get_circumference()  # Less intuitive\ncircle.get_area()\n```\n\n---\n\n### Summary Table: Benefits of Using `@property`\n\n| **Aspect**                   | **Without `@property`**                            | **With `@property`**                              |\n|------------------------------|--------------------------------------------------|-------------------------------------------------|\n| **Derived Value Consistency** | Must manually update derived values when `radius` changes | Automatically consistent with the latest `radius` |\n| **Memory Efficiency**         | Derived values stored, taking additional memory  | Derived values computed only when accessed       |\n| **Code Readability**          | Requires explicit methods (e.g., `get_circumference`) | Attribute-like access (`circle.circumference`)  |\n| **Error-Prone**               | Risk of forgetting to update derived attributes  | Eliminates manual synchronization               |\n\n---\n\nBy using `@property`, the `Circle` class ensures that attributes like `circumference` and `area` are always accurate, efficient, and easy to access, while avoiding potential issues like data inconsistency or unnecessary memory usage.\n\n",
    "supporting": [
      "oop-property_files"
    ],
    "filters": [],
    "includes": {}
  }
}