{
  "hash": "a8e9ad30ff533bf357d673f981cc0207",
  "result": {
    "engine": "jupyter",
    "markdown": "# Closures and Decorators in Python\n\n## Code Example\n\n**Source:**\n\n- Youtube: [Closures - How to Use Them and Why They Are Useful](https://www.youtube.com/watch?v=swU3c34d2NQ)\n- [GitHub](https://github.com/CoreyMSchafer/code_snippets/blob/master/Closures/closure.py)\n\n::: {#3f7e06a7 .cell execution_count=1}\n``` {.python .cell-code}\n# Closures\n\nimport logging\nlogging.basicConfig(filename='example.log', level=logging.INFO)\n\n\ndef logger(func):\n    def log_func(*args):\n        logging.info(\n            'Running \"{}\" with arguments {}'.format(func.__name__, args))\n        print(func(*args))\n    return log_func\n\n\ndef add(x, y):\n    return x+y\n\n\ndef sub(x, y):\n    return x-y\n\nadd_logger = logger(add)\nsub_logger = logger(sub)\n\nprint(add_logger(3, 3))\nprint(add_logger(4, 5))\n\nprint(sub_logger(10, 5))\nprint(sub_logger(20, 10))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\nNone\n9\nNone\n5\nNone\n10\nNone\n```\n:::\n:::\n\n\nThe code you've shared demonstrates closures in Python, but not yet decorators. Let me explain how closures work in your example, and then show how to transform this into using decorators.\n\n## What's Happening\n\nYour example uses a closure - where `logger` is a function that returns another function (`log_func`). This inner function \"closes over\" and remembers the `func` variable from its parent scope.\n\nWhen you call:\n\n::: {#eab1914f .cell execution_count=2}\n``` {.python .cell-code}\nadd_logger = logger(add)\n```\n:::\n\n\nYou're creating a new function (`log_func`) that:\n\n1. Has access to the `add` function (stored in the `func` parameter)\n2. Logs information before executing the original function\n3. Prints the result of the function call\n\n## Converting to a Decorator\n\nDecorators are a syntactic way to apply this closure pattern. Here's how to convert your example to use decorators:\n\n::: {#0c3a0316 .cell execution_count=3}\n``` {.python .cell-code}\nimport logging\nlogging.basicConfig(filename='example.log', level=logging.INFO)\n\ndef logger(func):\n    def log_func(*args):\n        logging.info(\n            'Running \"{}\" with arguments {}'.format(func.__name__, args))\n        print(func(*args))\n    return log_func\n\n# Apply decorator to functions\n@logger\ndef add(x, y):\n    return x+y\n\n@logger\ndef sub(x, y):\n    return x-y\n\n# Now you can call the functions directly\nadd(3, 3)\nadd(4, 5)\n\nsub(10, 5)\nsub(20, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n9\n5\n10\n```\n:::\n:::\n\n\nThe `@logger` syntax is shorthand for `add = logger(add)`. It automatically wraps your function with the logger functionality.\n\n## How Decorators Work\n\nWhen you use the `@decorator` syntax:\n\n1. Python defines the function (e.g., `add`)\n2. It then passes this function to the decorator (`logger`)\n3. The decorator returns a new function (the inner `log_func`)\n4. This new function replaces the original function\n\n## Adding Parameters to Decorators\n\nYou can also create decorators that accept parameters. This involves adding another layer of functions:\n\n::: {#36abbdc4 .cell execution_count=4}\n``` {.python .cell-code}\nimport logging\nlogging.basicConfig(filename='example.log', level=logging.INFO)\n\ndef logger_with_level(level=logging.INFO):\n    def decorator(func):\n        def log_func(*args):\n            logging.log(level, \n                'Running \"{}\" with arguments {}'.format(func.__name__, args))\n            result = func(*args)\n            print(result)\n            return result\n        return log_func\n    return decorator\n\n@logger_with_level(level=logging.DEBUG)\ndef add(x, y):\n    return x+y\n\n@logger_with_level()  # Using default level\ndef sub(x, y):\n    return x-y\n\nadd(3, 3)\nsub(10, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n5\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n5\n```\n:::\n:::\n\n\n## Preserving Function Metadata\n\nOne issue with decorators is that they replace the original function, including its name and docstring. To fix this, use `functools.wraps`:\n\n::: {#be395b7a .cell execution_count=5}\n``` {.python .cell-code}\nimport logging\nimport functools\nlogging.basicConfig(filename='example.log', level=logging.INFO)\n\ndef logger(func):\n    @functools.wraps(func)  # Preserves function metadata\n    def log_func(*args):\n        logging.info(\n            'Running \"{}\" with arguments {}'.format(func.__name__, args))\n        result = func(*args)\n        print(result)\n        return result\n    return log_func\n\n@logger\ndef add(x, y):\n    \"\"\"Add two numbers and return the result.\"\"\"\n    return x+y\n\n# Now add.__name__ will be 'add' instead of 'log_func'\n# and add.__doc__ will still be available\nprint(add.__name__)  # Output: add\nprint(add.__doc__)   # Output: Add two numbers and return the result.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nadd\nAdd two numbers and return the result.\n```\n:::\n:::\n\n\n## Closure vs. Decorator: Comparison\n\n| Aspect | Closure Approach | Decorator Approach |\n|--------|------------------|-------------------|\n| Syntax | `add_logger = logger(add)` | `@logger` above function |\n| Function usage | Call wrapped function: `add_logger(3, 3)` | Call original function name: `add(3, 3)` |\n| Code clarity | Separate wrapping from function definition | Wrapping happens at function definition |\n| Metadata preservation | Original function name/docs lost | Can preserve with `functools.wraps` |\n| Reusability | Requires explicit wrapping of each function | Can apply to multiple functions with same syntax |\n| Nested application | More verbose with multiple wrappers | Clean syntax for multiple decorators: `@dec1 @dec2` |\n\nWould you like me to explain any specific aspect of decorators in more detail?\n\n",
    "supporting": [
      "closure-decorator_files"
    ],
    "filters": [],
    "includes": {}
  }
}