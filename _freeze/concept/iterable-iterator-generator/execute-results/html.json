{
  "hash": "bef5a6cb7c1b8580da05fd021781d2a5",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Iterator, iterable, and Generator\"\n---\n\n\n\n\n::: {.callout-note appearance=\"minimal\"}\n\n**Q:** What's the difference between iterator, iterable, and generator?\n:::\n\n\n## Iterable\n\nAn **iterable** is any Python object that can return an iterator. These objects implement the `__iter__()` method, which returns an iterator when called. \n\n- **Examples of iterables**: Lists, tuples, dictionaries, sets, strings, and any object that implements `__iter__()`.\n  \n### Characteristics:\n\n- **Can be iterated** over in a `for` loop.\n- **Does not** necessarily keep track of its iteration state.\n- Calling `iter(iterable)` will return an **iterator** for that iterable.\n\n### Example:\n\n```python\n# A list is an iterable\nmy_list = [1, 2, 3]\n\nfor item in my_list:  # Iterating over the iterable\n    print(item)\n```\n\nIn this example, `my_list` is an iterable because it can return an iterator that can be used in a `for` loop.\n\n## Iterator\n\nAn **iterator** is an object that represents a stream of data. It implements the `__iter__()` and `__next__()` methods:\n\n- **`__iter__()`**: Returns the iterator object itself.\n- **`__next__()`**: Returns the next value from the iterator. When there are no more items, it raises the `StopIteration` exception.\n\nAn iterator **remembers its state** during iteration, meaning once a value has been accessed, it cannot be revisited without creating a new iterator.\n\n### Characteristics:\n\n- **Maintains state**: Keeps track of where it is during iteration.\n- **Consumes values** as they are accessed.\n- Can only move forward, not backward.\n\n### Example:\n\n::: {#cb76ecad .cell execution_count=1}\n``` {.python .cell-code}\n# Getting an iterator from an iterable\nmy_list = [1, 2, 3]\nmy_iter = iter(my_list)  # my_iter is an iterator\n\n# Manually iterate using next()\nprint(next(my_iter))  # Output: 1\nprint(next(my_iter))  # Output: 2\nprint(next(my_iter))  # Output: 3\n# The following will raise StopIteration\n# print(next(my_iter))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n```\n:::\n:::\n\n\nIn this example, `my_iter` is an iterator that returns one element of the list at a time when `next()` is called.\n\n## Generator\n\nA **generator** is a special type of iterator that is defined using a function with the `yield` keyword. Generators allow you to **generate values lazily**, meaning values are produced only when requested, not all at once.\n\nGenerators are a type of iterator because they also implement the `__iter__()` and `__next__()` methods, but they are written in a simpler way, using `yield`.\n\n### Characteristics:\n\n- **Lazy evaluation**: Values are generated on the fly, one at a time, which makes generators memory-efficient for large datasets.\n- Once a generator has been exhausted, it **cannot be reused** unless recreated.\n- **Simpler syntax**: Typically easier to write than iterators, using `yield` instead of managing `__iter__()` and `__next__()` methods manually.\n\n### Example:\n\n::: {#9c51e820 .cell execution_count=2}\n``` {.python .cell-code}\n# A generator function\ndef my_generator():\n    yield 1\n    yield 2\n    yield 3\n\ngen = my_generator()  # gen is a generator\n\n# Iterate over the generator\nfor value in gen:\n    print(value)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n2\n3\n```\n:::\n:::\n\n\nIn this example, the `my_generator()` function is a generator. It \"yields\" values one at a time and can be used like an iterator.\n\n### Generator Expression:\n\nYou can also create a generator using a **generator expression**, which is similar to a list comprehension but with parentheses:\n\n```python\n# Generator expression\ngen_exp = (x * x for x in range(3))\n\n# Iterate over the generator expression\nfor value in gen_exp:\n    print(value)  # Output: 0, 1, 4\n```\n\n## Key Differences:\n\n| Concept     | Characteristics | Methods | Example Usage |\n|-------------|------------------|---------|---------------|\n| **Iterable** | Any object you can iterate over (e.g., lists, strings, etc.). Produces an iterator when `iter()` is called. | `__iter__()` | Lists, sets, strings, dictionaries, etc. |\n| **Iterator** | Object that represents a stream of data. Iterates once and keeps its state. | `__iter__()`, `__next__()` | Result of calling `iter()` on an iterable. |\n| **Generator** | A type of iterator created using a function with `yield`. Lazily produces values on demand. | `__iter__()`, `__next__()` | Generator functions or generator expressions. |\n\n### Summary:\n\n- **Iterable**: Anything that can be iterated over, like a list, tuple, or string.\n- **Iterator**: An object that keeps track of its position during iteration and produces the next value when requested.\n- **Generator**: A type of iterator that is defined using `yield` and is more memory-efficient because it generates values on the fly.\n\nIn short:\n\n- **Iterable**: Can return an iterator.\n- **Iterator**: An object that can iterate over its values, one by one.\n- **Generator**: A special iterator that is lazily evaluated, producing values as needed.\n\n",
    "supporting": [
      "iterable-iterator-generator_files"
    ],
    "filters": [],
    "includes": {}
  }
}