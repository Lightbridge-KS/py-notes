{
  "hash": "13bb3287d27ed5eb7ad1d5d816c7e01d",
  "result": {
    "markdown": "---\ntitle: \"Intro to PD\"\n---\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nimport numpy as np\nfrom pandas import Series, DataFrame\n```\n:::\n\n\n## Series\n\n### Creation\n\n\n::: {.cell}\n\n```{.python .cell-code}\nobj = pd.Series([4, 7, -5, 3])\ntype(obj)\n#> <class 'pandas.core.series.Series'>\nobj\n#> 0    4\n#> 1    7\n#> 2   -5\n#> 3    3\n#> dtype: int64\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Array Representation\nobj.array\n#> <NumpyExtensionArray>\n#> [4, 7, -5, 3]\n#> Length: 4, dtype: int64\ntype(obj.array)\n#> <class 'pandas.core.arrays.numpy_.NumpyExtensionArray'>\n\n# Index\nobj.index\n#> RangeIndex(start=0, stop=4, step=1)\ntype(obj.index)\n#> <class 'pandas.core.indexes.range.RangeIndex'>\n```\n:::\n\n\n\nSeries with index\n\n\n::: {.cell}\n\n```{.python .cell-code}\nobj2 = pd.Series([4, 7, -5, 3], index=[\"d\", \"b\", \"a\", \"c\"])\nobj2\n#> d    4\n#> b    7\n#> a   -5\n#> c    3\n#> dtype: int64\n\n# Index\nobj2.index\n#> Index(['d', 'b', 'a', 'c'], dtype='object')\n```\n:::\n\n\nFrom `Dict`\n\n\n::: {.cell}\n\n```{.python .cell-code}\nsdata = {\"Ohio\": 35000, \"Texas\": 71000, \"Oregon\": 16000, \"Utah\": 5000}\nobj3 = pd.Series(sdata)\nobj3\n#> Ohio      35000\n#> Texas     71000\n#> Oregon    16000\n#> Utah       5000\n#> dtype: int64\n```\n:::\n\n\nBack to `Dict`, `List`, etc.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nobj3.to_dict()\n#> {'Ohio': 35000, 'Texas': 71000, 'Oregon': 16000, 'Utah': 5000}\nobj3.to_list()\n#> [35000, 71000, 16000, 5000]\n```\n:::\n\n\n\n\n### Subset Series\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Position\nobj2[0] \n#> 4\n#> \n#> <string>:2: FutureWarning: Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`\n\n# Index\nobj2[\"d\"]\n#> 4\n\n# list of indices\nobj2[[\"d\", \"a\"]]\n#> d    4\n#> a   -5\n#> dtype: int64\n\n# Logical\nobj2[obj2 > 0]\n#> d    4\n#> b    7\n#> c    3\n#> dtype: int64\n\n# Assign\nobj2[\"c\"] = 10\nobj2\n#> d     4\n#> b     7\n#> a    -5\n#> c    10\n#> dtype: int64\n```\n:::\n\n\n### Vectorized Operation\n\n\n::: {.cell}\n\n```{.python .cell-code}\nobj2 * 2\n#> d     8\n#> b    14\n#> a   -10\n#> c    20\n#> dtype: int64\n```\n:::\n\n\n Series is as a fixed-length, ordered dictionary\n \n\n::: {.cell}\n\n```{.python .cell-code}\n\"b\" in obj2\n#> True\n```\n:::\n\n \n\n### Missing Value\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = pd.Series([1, 2, None])\nx\n#> 0    1.0\n#> 1    2.0\n#> 2    NaN\n#> dtype: float64\n# Check NA\nx.isna()\n#> 0    False\n#> 1    False\n#> 2     True\n#> dtype: bool\nx.notna()\n#> 0     True\n#> 1     True\n#> 2    False\n#> dtype: bool\n```\n:::\n\n\n\n### Auto-align arithmatic\n\n\n::: {.cell}\n\n```{.python .cell-code}\nstates = [\"California\", \"Ohio\", \"Oregon\", \"Texas\"]\nobj4 = pd.Series(sdata, index=states)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nobj3\n#> Ohio      35000\n#> Texas     71000\n#> Oregon    16000\n#> Utah       5000\n#> dtype: int64\nobj4\n#> California        NaN\n#> Ohio          35000.0\n#> Oregon        16000.0\n#> Texas         71000.0\n#> dtype: float64\n```\n:::\n\n\nData alignment features\n\n\n::: {.cell}\n\n```{.python .cell-code}\nobj3 + obj4\n#> California         NaN\n#> Ohio           70000.0\n#> Oregon         32000.0\n#> Texas         142000.0\n#> Utah               NaN\n#> dtype: float64\n```\n:::\n\n\n\n### `name` Attribute\n\n\n::: {.cell}\n\n```{.python .cell-code}\nobj4.name = \"population\"\nobj4.index.name = \"state\"\nobj4\n#> state\n#> California        NaN\n#> Ohio          35000.0\n#> Oregon        16000.0\n#> Texas         71000.0\n#> Name: population, dtype: float64\n```\n:::\n\n\n\n## DataFrame\n\nSee [Comparison with R data.frame](https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_r.html#compare-with-r)\n\n\nit can be thought of as a dictionary of Series all sharing the same index.\n\n### Creation\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndata = {\"state\": [\"Ohio\", \"Ohio\", \"Ohio\", \"Nevada\", \"Nevada\", \"Nevada\"],\n        \"year\": [2000, 2001, 2002, 2001, 2002, 2003],\n        \"pop\": [1.5, 1.7, 3.6, 2.4, 2.9, 3.2]}\n        \nframe = pd.DataFrame(data)\ntype(frame)\n#> <class 'pandas.core.frame.DataFrame'>\nframe\n#>     state  year  pop\n#> 0    Ohio  2000  1.5\n#> 1    Ohio  2001  1.7\n#> 2    Ohio  2002  3.6\n#> 3  Nevada  2001  2.4\n#> 4  Nevada  2002  2.9\n#> 5  Nevada  2003  3.2\n```\n:::\n\n\nWith specified column arrangement \n  \n\n::: {.cell}\n\n```{.python .cell-code}\nframe2 = pd.DataFrame(data, columns=[\"year\", \"state\", \"pop\", \"debt\"])\nframe2\n#>    year   state  pop debt\n#> 0  2000    Ohio  1.5  NaN\n#> 1  2001    Ohio  1.7  NaN\n#> 2  2002    Ohio  3.6  NaN\n#> 3  2001  Nevada  2.4  NaN\n#> 4  2002  Nevada  2.9  NaN\n#> 5  2003  Nevada  3.2  NaN\n\n# Column names\nframe2.columns.to_list()\n#> ['year', 'state', 'pop', 'debt']\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Shape\nframe.shape\n#> (6, 3)\n# Head\nframe.head()\n#>     state  year  pop\n#> 0    Ohio  2000  1.5\n#> 1    Ohio  2001  1.7\n#> 2    Ohio  2002  3.6\n#> 3  Nevada  2001  2.4\n#> 4  Nevada  2002  2.9\n# Tail\nframe.tail(3)\n#>     state  year  pop\n#> 3  Nevada  2001  2.4\n#> 4  Nevada  2002  2.9\n#> 5  Nevada  2003  3.2\n```\n:::\n\n \n \nNested dictionary\n\n\n::: {.cell}\n\n```{.python .cell-code}\npopulations = {\"Ohio\": {2000: 1.5, 2001: 1.7, 2002: 3.6},\n               \"Nevada\": {2001: 2.4, 2002: 2.9}}\n\npd.DataFrame(populations)\n#>       Ohio  Nevada\n#> 2000   1.5     NaN\n#> 2001   1.7     2.4\n#> 2002   3.6     2.9\n```\n:::\n\n\n \n \n### Subset\n\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2.head()\n#>    year   state  pop debt\n#> 0  2000    Ohio  1.5  NaN\n#> 1  2001    Ohio  1.7  NaN\n#> 2  2002    Ohio  3.6  NaN\n#> 3  2001  Nevada  2.4  NaN\n#> 4  2002  Nevada  2.9  NaN\n```\n:::\n\n \n### Select -> `[[`\n\n`R`\n\n```r\nselect(df, col1, col2)\n```\n\n`Py`\n\n```python\ndf[['col1', 'col2']]\n```\n \n \nSelect 1 column\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Quote or unquote\nframe2[\"state\"]\n#> 0      Ohio\n#> 1      Ohio\n#> 2      Ohio\n#> 3    Nevada\n#> 4    Nevada\n#> 5    Nevada\n#> Name: state, dtype: object\n\nframe2[\"state\"] is frame2.state\n#> True\n\ntype(frame2.state) # Series\n#> <class 'pandas.core.series.Series'>\n```\n:::\n\n\n Select multiple column\n \n\n::: {.cell}\n\n```{.python .cell-code}\nframe2sub = frame2[[\"state\", \"pop\"]]\ntype(frame2sub) # DF\n#> <class 'pandas.core.frame.DataFrame'>\nframe2sub\n#>     state  pop\n#> 0    Ohio  1.5\n#> 1    Ohio  1.7\n#> 2    Ohio  3.6\n#> 3  Nevada  2.4\n#> 4  Nevada  2.9\n#> 5  Nevada  3.2\n```\n:::\n\n \n \n### Slice \n\n`R`\n\n```r\nslice(df, 1:10)\n```\n\n`Py`\n\n```python\ndf.iloc[:9]\n```\n\n\n::: {.cell}\n\n```{.python .cell-code}\nframe\n#>     state  year  pop\n#> 0    Ohio  2000  1.5\n#> 1    Ohio  2001  1.7\n#> 2    Ohio  2002  3.6\n#> 3  Nevada  2001  2.4\n#> 4  Nevada  2002  2.9\n#> 5  Nevada  2003  3.2\nframe.iloc[:3]\n#>   state  year  pop\n#> 0  Ohio  2000  1.5\n#> 1  Ohio  2001  1.7\n#> 2  Ohio  2002  3.6\n```\n:::\n\n\n\n \n### Filter -> `query`\n \n`R`\n\n```r\nfilter(df, col1 == 1, col2 == 1)\n```\n\n`Py`\n\n```python\ndf.query('col1 == 1 & col2 == 1')\n```\n\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2\n#>    year   state  pop debt\n#> 0  2000    Ohio  1.5  NaN\n#> 1  2001    Ohio  1.7  NaN\n#> 2  2002    Ohio  3.6  NaN\n#> 3  2001  Nevada  2.4  NaN\n#> 4  2002  Nevada  2.9  NaN\n#> 5  2003  Nevada  3.2  NaN\n\nframe2[frame2.state == \"Ohio\"]\n#>    year state  pop debt\n#> 0  2000  Ohio  1.5  NaN\n#> 1  2001  Ohio  1.7  NaN\n#> 2  2002  Ohio  3.6  NaN\n# Or\nframe2.query('state == \"Ohio\"')\n#>    year state  pop debt\n#> 0  2000  Ohio  1.5  NaN\n#> 1  2001  Ohio  1.7  NaN\n#> 2  2002  Ohio  3.6  NaN\n\nframe2.query('pop > 1.5')\n#>    year   state  pop debt\n#> 1  2001    Ohio  1.7  NaN\n#> 2  2002    Ohio  3.6  NaN\n#> 3  2001  Nevada  2.4  NaN\n#> 4  2002  Nevada  2.9  NaN\n#> 5  2003  Nevada  3.2  NaN\n```\n:::\n\n\n\n\n \n### Mutate -> `assign`\n\n`R`: `mutate(df, c=a-b)`\n\n`Py`: `df.assign(c=df['a']-df['b'])`\n\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2.assign(pop2 = frame2[\"pop\"] * 2)\n#>    year   state  pop debt  pop2\n#> 0  2000    Ohio  1.5  NaN   3.0\n#> 1  2001    Ohio  1.7  NaN   3.4\n#> 2  2002    Ohio  3.6  NaN   7.2\n#> 3  2001  Nevada  2.4  NaN   4.8\n#> 4  2002  Nevada  2.9  NaN   5.8\n#> 5  2003  Nevada  3.2  NaN   6.4\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2[\"debt\"] = np.arange(6.)\nframe2\n#>    year   state  pop  debt\n#> 0  2000    Ohio  1.5   0.0\n#> 1  2001    Ohio  1.7   1.0\n#> 2  2002    Ohio  3.6   2.0\n#> 3  2001  Nevada  2.4   3.0\n#> 4  2002  Nevada  2.9   4.0\n#> 5  2003  Nevada  3.2   5.0\n```\n:::\n\n \nAssign by index of series \n \n\n::: {.cell}\n\n```{.python .cell-code}\nval = pd.Series([-1.2, -1.5, -1.7], index=[2, 4, 5])\nval\n#> 2   -1.2\n#> 4   -1.5\n#> 5   -1.7\n#> dtype: float64\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2.debt = val\nframe2\n#>    year   state  pop  debt\n#> 0  2000    Ohio  1.5   NaN\n#> 1  2001    Ohio  1.7   NaN\n#> 2  2002    Ohio  3.6  -1.2\n#> 3  2001  Nevada  2.4   NaN\n#> 4  2002  Nevada  2.9  -1.5\n#> 5  2003  Nevada  3.2  -1.7\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2[\"pop2\"] = frame2[\"pop\"] * 2\nframe2\n#>    year   state  pop  debt  pop2\n#> 0  2000    Ohio  1.5   NaN   3.0\n#> 1  2001    Ohio  1.7   NaN   3.4\n#> 2  2002    Ohio  3.6  -1.2   7.2\n#> 3  2001  Nevada  2.4   NaN   4.8\n#> 4  2002  Nevada  2.9  -1.5   5.8\n#> 5  2003  Nevada  3.2  -1.7   6.4\n```\n:::\n\n \n\n \n \n### Rename\n\n```r\nrename(df, col_one = col1)\n```\n\n```python\ndf.rename(columns={'col1': 'col_one'})\n```\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2.rename(columns = {'year': 'yr'})\n#>      yr   state  pop  debt  pop2\n#> 0  2000    Ohio  1.5   NaN   3.0\n#> 1  2001    Ohio  1.7   NaN   3.4\n#> 2  2002    Ohio  3.6  -1.2   7.2\n#> 3  2001  Nevada  2.4   NaN   4.8\n#> 4  2002  Nevada  2.9  -1.5   5.8\n#> 5  2003  Nevada  3.2  -1.7   6.4\n```\n:::\n\n\n\n### Summarize\n\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2.describe()\n#>               year       pop      debt      pop2\n#> count     6.000000  6.000000  3.000000  6.000000\n#> mean   2001.500000  2.550000 -1.466667  5.100000\n#> std       1.048809  0.836062  0.251661  1.672124\n#> min    2000.000000  1.500000 -1.700000  3.000000\n#> 25%    2001.000000  1.875000 -1.600000  3.750000\n#> 50%    2001.500000  2.650000 -1.500000  5.300000\n#> 75%    2002.000000  3.125000 -1.350000  6.250000\n#> max    2003.000000  3.600000 -1.200000  7.200000\n```\n:::\n\n\n### Group by, Summarize\n\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2.head()\n#>    year   state  pop  debt  pop2\n#> 0  2000    Ohio  1.5   NaN   3.0\n#> 1  2001    Ohio  1.7   NaN   3.4\n#> 2  2002    Ohio  3.6  -1.2   7.2\n#> 3  2001  Nevada  2.4   NaN   4.8\n#> 4  2002  Nevada  2.9  -1.5   5.8\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nframe2.groupby('state').agg({'pop': 'mean'})\n#>              pop\n#> state           \n#> Nevada  2.833333\n#> Ohio    2.266667\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}