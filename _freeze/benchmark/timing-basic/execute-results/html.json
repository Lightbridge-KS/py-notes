{
  "hash": "736b6b65e15057865f7f0399e984a04b",
  "result": {
    "engine": "jupyter",
    "markdown": "# Timing \n\n::: {.callout-note appearance=\"simple\" collapse=\"false\"}\nQ: How to time the execution of a given block of code and save the result to a variable\n:::\n\n## Basic Timing\n\nI'll show you how to time code execution in Python using different methods, focusing on your preference for clean and efficient code.\n\nHere's a comprehensive solution using different approaches:\n\n### Context manager\n\n::: {#c407521e .cell execution_count=1}\n``` {.python .cell-code}\nimport time\nfrom contextlib import contextmanager\nimport timeit\n\n@contextmanager\ndef timer():\n    \"\"\"Time the execution of a code block.\n    \n    Returns\n    -------\n    float\n        Time elapsed in seconds.\n    \n    Examples\n    --------\n    >>> with timer() as t:\n    ...     # Your code here\n    ...     time.sleep(1)\n    >>> print(f\"Elapsed time: {t:.4f} seconds\")\n    \"\"\"\n    start = time.perf_counter()\n    elapsed = -1  # Default value if error occurs\n    \n    try:\n        yield lambda: elapsed\n    finally:\n        elapsed = time.perf_counter() - start\n```\n:::\n\n\n::: {#758e7b01 .cell execution_count=2}\n``` {.python .cell-code}\nwith timer() as t:\n    # Your code block here\n    time.sleep(0.5)  # Simulate work\nelapsed_time = t()\nprint(f\"Elapsed time: {elapsed_time:.4f} seconds\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nElapsed time: 0.5051 seconds\n```\n:::\n:::\n\n\n### timeit\n\nExample usage 2: Using timeit for more accurate benchmarking\n\n::: {#9c1bb2de .cell execution_count=3}\n``` {.python .cell-code}\ndef code_to_time():\n    # Your code block here\n    time.sleep(0.5)  # Simulate work\n\nexecution_time = timeit.timeit(code_to_time, number=1)\nprint(f\"Execution time: {execution_time:.4f} seconds\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExecution time: 0.5015 seconds\n```\n:::\n:::\n\n\nKey features of this implementation:\n\n1. Uses `contextmanager` for clean syntax and proper resource management\n2. Uses `time.perf_counter()` which is more precise than `time.time()`\n3. Implements error handling as per your preference\n4. Returns the elapsed time as a variable for further use\n5. Provides an alternative using `timeit` for more accurate benchmarking\n\n## Benchmarking\n\nFor timing multiple iterations or getting statistics, you can use this extended version:\n\n::: {#31ee625f .cell execution_count=4}\n``` {.python .cell-code}\ndef benchmark(func, iterations=100):\n    \"\"\"Benchmark a function's execution time over multiple iterations.\n    \n    Parameters\n    ----------\n    func : callable\n        Function to benchmark\n    iterations : int, optional\n        Number of iterations, by default 100\n    \n    Returns\n    -------\n    dict\n        Dictionary containing timing statistics\n    \"\"\"\n    times = []\n    \n    for _ in range(iterations):\n        with timer() as t:\n            func()\n        times.append(t())\n    \n    return {\n        'mean': sum(times) / len(times),\n        'min': min(times),\n        'max': max(times),\n        'iterations': iterations\n    }\n\n# Example usage\ndef sample_function():\n    time.sleep(0.1)  # Simulate work\n\nresults = benchmark(sample_function, iterations=5)\nprint(f\"Mean time: {results['mean']:.4f} seconds\")\nprint(f\"Min time: {results['min']:.4f} seconds\")\nprint(f\"Max time: {results['max']:.4f} seconds\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMean time: 0.1046 seconds\nMin time: 0.1026 seconds\nMax time: 0.1051 seconds\n```\n:::\n:::\n\n\nChoose the method that best fits your needs:\n\n1. Use the `timer()` context manager for simple, one-off timing\n2. Use `timeit` for more accurate benchmarking\n3. Use the `benchmark()` function for statistical analysis of execution times\n\n",
    "supporting": [
      "timing-basic_files"
    ],
    "filters": [],
    "includes": {}
  }
}