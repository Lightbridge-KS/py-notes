{
  "hash": "4aa7d0bf1d4d1c6bc34a0175bf864f5a",
  "result": {
    "engine": "jupyter",
    "markdown": "# Python Preferences\n\nHere are my Python Preferences. \n\n## List Comprehension\n\nFor simple cases, I prefer list comprehension over for loop.\n\n### Nested Comprehension\n\nFor simple nested loops of no more than two level deep, I still prefer list comprehension over for loop.\n\n<example>\n\n::: {#d27ec928 .cell execution_count=1}\n``` {.python .cell-code}\ncolors = [\"orange\", \"purple\", \"pink\"]\ntoys = [\"bike\", \"basketball\", \"skateboard\", \"doll\"]\n\n[ color + \" \" + toy\n  for color in colors\n  for toy in toys ]\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n['orange bike',\n 'orange basketball',\n 'orange skateboard',\n 'orange doll',\n 'purple bike',\n 'purple basketball',\n 'purple skateboard',\n 'purple doll',\n 'pink bike',\n 'pink basketball',\n 'pink skateboard',\n 'pink doll']\n```\n:::\n:::\n\n\n</example>\n\n### Filtered Comprehension\n\nFor filtering elements based on a condition, I prefer list comprehension over for loop.\n\n<example>\n\n::: {#ab9c304e .cell execution_count=2}\n``` {.python .cell-code}\nnumbers = [ 9, -1, -4, 20, 11, -3 ]\n\nodd_positives = [\n    num for num in numbers\n    if num > 0 or num % 2 == 1\n]\n```\n:::\n\n\nOr, alternatively:\n\n::: {#cda348b7 .cell execution_count=3}\n``` {.python .cell-code}\nnumbers = [ 9, -1, -4, 20, 11, -3 ]\n\ndef num_is_valid(num):\n    return num % 2 == 0 or num % 3 == 0\n\n[ num for num in numbers \n  if num_is_valid(num)]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[9, -4, 20, -3]\n```\n:::\n:::\n\n\n</example>\n\n## Exception Handling\n\n- I prefer specific exception handling over generic exception handling.\n- I prefer as little code as possible in the try block. You do this so your except block(s) will not catch or mask errors that they should not.\n\n### Logging Exceptions\n\nFor logging exceptions, I like using `logging` module to capture full stack trace.\n\n<example>\n\n::: {#8f807800 .cell execution_count=4}\n``` {.python .cell-code}\nimport logging\nUPLOAD_ROOT = \"fold/testdir\"\n\ndef create_upload_dir(username):\n    userdir = os.path.join(UPLOAD_ROOT, username)\n    try:\n        os.makedirs(userdir)\n    except FileExistsError as err:\n        logging.error(\"Upload dir already exists: %s\",\n            err.filename)\n```\n:::\n\n\n</example>\n\n### Generic Erors Catching\n\nFor generic error catching, I prefer to catch `logging.exception()`, which will log your message along with the full stack trace of the current exception.\n\n<example>\n\n::: {#3a3fbef4 .cell execution_count=5}\n``` {.python .cell-code}\nimport logging\n\ndef get_number():\n    return int('foo')\n\ntry:\n    x = get_number()\nexcept:\n    logging.exception('Caught an error')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nERROR:root:Caught an error\nTraceback (most recent call last):\n  File \"/var/folders/70/7wmmf6t55cb84bfx9g1c1k1m0000gn/T/ipykernel_98552/3758161683.py\", line 7, in <module>\n    x = get_number()\n  File \"/var/folders/70/7wmmf6t55cb84bfx9g1c1k1m0000gn/T/ipykernel_98552/3758161683.py\", line 4, in get_number\n    return int('foo')\nValueError: invalid literal for int() with base 10: 'foo'\n```\n:::\n:::\n\n\n</example>\n\n",
    "supporting": [
      "py-pref_files"
    ],
    "filters": [],
    "includes": {}
  }
}