{
  "hash": "ae67670dc0eaa565bff468fe3d2023ac",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"OOP in Python\"\n---\n\n\n\n\n\n\n- [OOP in Python (real python)](https://realpython.com/python3-object-oriented-programming/#what-is-object-oriented-programming-in-python)\n\n\n## Class\n\n### Define Class\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass Car:\n    \"Car Class\"\n    # Class Attribute\n    fuel = \"Electric\"\n    # initialize dunder\n    def __init__(self, color: str, mileage: int):\n        self.color = color\n        self.mileage = mileage\n    # Print dunder\n    def __str__(self) -> str:\n        return f\"color: {self.color}, mileage: {self.mileage}\"\n    # Instance method\n    def drive(self):\n        return f\"Ventured {self.mileage} miles\"            \n```\n:::\n\n\n\n\n### Create instance\n\nCreate instance of a class `Car`\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncar_blue = Car(\"blue\", 20000)\nprint(car_blue)\n#> color: blue, mileage: 20000\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Doc string\ncar_blue.__doc__\n#> 'Car Class'\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ncar_blue.__dict__\n#> {'color': 'blue', 'mileage': 20000}\n```\n:::\n\n\n\n\nAccess Attribute\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncar_turbo.fuel\n#> NameError: name 'car_turbo' is not defined\n```\n:::\n\n\n\n\nAccess method\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncar_turbo.drive()\n#> NameError: name 'car_turbo' is not defined\n```\n:::\n\n\n\n\n### Class attribute vs Instance attribute\n\n\n1. **Class Attributes**:\n    - Defined directly in the class body.\n    - Shared across all instances of the class.\n    - Accessed using the class name or through an instance.\n    - Changes to a class attribute affect all instances that haven’t overridden the attribute.\n\nExample:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass Manual:\n    A = \"hi\"\n    B = \"there\"\n\n# Accessing class attributes\nprint(Manual.A)  # Output: hi\n#> hi\nprint(Manual.B)  # Output: there\n#> there\n\n# Creating instances\nm1 = Manual()\nm2 = Manual()\n\n# Accessing class attributes through instances\nprint(m1.A)  \n#> hi\nprint(m2.A) \n#> hi\n\n# Modifying class attribute\nManual.A = \"hello\"\nprint(m1.A)  \n#> hello\nprint(m2.A)   \n#> hello\n```\n:::\n\n\n\n\n2. **Instance Attributes**:\n    - Defined within the `__init__` method.\n    - Unique to each instance of the class.\n    - Accessed using the instance name.\n    - Changes to an instance attribute affect only that instance.\n\nExample:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass Manual:\n    def __init__(self):\n        self.A = \"hi\"\n        self.B = \"there\"\n\n# Creating instances\nm1 = Manual()\nm2 = Manual()\n\n# Accessing instance attributes\nprint(m1.A)  \n#> hi\nprint(m2.A)  \n#> hi\n\n# Modifying instance attribute\nm1.A = \"hello\"\nprint(m1.A)  \n#> hello\nprint(m2.A)  \n#> hi\n```\n:::\n\n\n\n\n#### Key Differences\n\n1. **Scope and Sharing**:\n    - **Class Attributes**: Shared by all instances of the class. If you change a class attribute, the change is reflected in all instances unless overridden.\n    - **Instance Attributes**: Unique to each instance. Changing an instance attribute affects only that particular instance.\n\n2. **Definition and Initialization**:\n    - **Class Attributes**: Defined directly in the class body, outside any methods.\n    - **Instance Attributes**: Defined within the `__init__` method, which is called when a new instance of the class is created.\n\n3. **Usage Context**:\n    - **Class Attributes**: Useful for constants or attributes that should be shared across all instances.\n    - **Instance Attributes**: Used for attributes that need to be unique to each instance, such as data specific to that instance.\n\n#### Summary\n\n- Use **class attributes** when you want to share data across all instances of the class.\n- Use **instance attributes** when you need each instance of the class to have its own unique data.\n\n### Interitance\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass Parent:\n    hair_color = \"brown\"\n\nclass Child(Parent):\n    pass\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nch1 = Child()\nch1.hair_color\n#> 'brown'\n```\n:::\n\n\n\n\n**Overwrite Parent**\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass Parent:\n    hair_color = \"brown\"\n\nclass Child(Parent):\n    hair_color = \"purple\" # Overwrite\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nch2 = Child()\nch2.hair_color\n#> 'purple'\n```\n:::\n\n\n\n\n**Extend Parent Attribute**\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass Parent:\n    speaks = [\"English\"]\n\nclass Child(Parent):\n    def __init__(self):\n        super().__init__()\n        self.speaks.append(\"German\")\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nch3 = Child()\nch3.hair_color\n#> AttributeError: 'Child' object has no attribute 'hair_color'\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Check parent class\ntype(ch3) \n#> <class '__main__.Child'>\nisinstance(ch3, Parent)\n#> True\n```\n:::\n\n\n\n\n### Multiple Child from Parent Class\n\n**Parent Class**\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __str__(self):\n        return f\"{self.name} is {self.age} years old\"\n\n    def speak(self, sound=\"...\"):\n        return f\"{self.name} says {sound}\"\n```\n:::\n\n\n\n\n**Child Class**\n\nEach dog breed bark differently\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nclass JackRussellTerrier(Dog):\n    def speak(self, sound=\"Arf\"):\n        return super().speak(sound)\n\nclass Bulldog(Dog):\n    def speak(self, sound=\"Woof\"):\n        return super().speak(sound)\n\nclass Dachshund(Dog):\n    pass\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nmiles = JackRussellTerrier(\"Miles\", 4)\nbuddy = Dachshund(\"Buddy\", 9)\njack = Bulldog(\"Jack\", 3)\njim = Bulldog(\"Jim\", 5)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nmiles.speak()\n#> 'Miles says Arf'\nbuddy.speak()\n#> 'Buddy says ...'\n```\n:::\n\n\n\n\n## DataClass\n\n\n### Ex1: Create Simple (Recist) \n\n\nYou can convert the `Recist` class to a `dataclass` in Python by using the `dataclasses` module, which simplifies the creation of classes by automatically generating special methods like `__init__`, `__repr__`, and `__eq__`. Here’s how you can do it:\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Recist:\n    category: str\n    category_full: str = field(init=False)\n    \n    _category_dict = {\n        \"PR\": \"Partial Response (PR)\",\n        \"CR\": \"Complete Response (CR)\",\n        \"PD\": \"Progressive Disease (PD)\",\n        \"SD\": \"Stable Disease (SD)\"\n    }\n\n    def __post_init__(self):\n        # Set the full category name based on the provided short category\n        if self.category in self._category_dict:\n            self.category_full = self._category_dict[self.category]\n        else:\n            raise ValueError(f\"Unknown category: {self.category}\")\n```\n:::\n\n\n\n\n**Explanation:**\n\n- **`@dataclass` Decorator:** This decorator is used to create a data class, which automatically generates the `__init__` method and other utility methods based on the fields you define.\n- **Fields:**\n  - `category`: This is the input field where you pass the short form of the RECIST category.\n  - `category_full`: This field is automatically computed based on the `category` and does not need to be initialized by the user. It is marked with `field(init=False)` to exclude it from the generated `__init__` method.\n- **`__post_init__` Method:** This special method is automatically called after the `__init__` method. It's used here to set `category_full` based on the provided `category` value. If the `category` is not in the `_category_dict`, an exception is raised.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Creating an instance of the Recist class\nrecist_instance = Recist(category=\"PR\")\nprint(recist_instance.category)       # Output: \"PR\"\n#> PR\nprint(recist_instance.category_full)  # Output: \"Partial Response (PR)\"\n#> Partial Response (PR)\n\n# Handling an invalid category\ntry:\n    invalid_instance = Recist(category=\"XX\")\nexcept ValueError as e:\n    print(e)  # Output: \"Unknown category: XX\"\n#> Unknown category: XX\n```\n:::\n",
    "supporting": [
      "oop_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}