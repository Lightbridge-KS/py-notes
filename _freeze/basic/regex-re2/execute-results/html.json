{
  "hash": "22791242f39161529d198fe223410f15",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Re2 vs Re\n---\n\n\n\n\nBoth Python's built-in `re` module and Google's `re2` module are used for regular expression operations, but they have some important differences in their implementation and API. Let's examine each of the functions you mentioned.\n\n## Compile\n\n::: {#0f604f14 .cell execution_count=1}\n``` {.python .cell-code}\nimport re\nimport re2\ntext = \"Hello, my email is example@example.com\"\npattern = r'(\\w+)@(\\w+)\\.com'\n\nre.compile(pattern, 0)\nre2.compile(pattern, 0)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n<re2._Regexp at 0x137b3e620>\n```\n:::\n:::\n\n\n## `search()`\n\n### Basic API Structure\n\n**`re.search()`**:\n\n```python\nre.search(pattern, string, flags=0)\n```\n\n**`re2.search()`**:\n\n```python\nre2.search(pattern, string, flags=0)\n```\n\n### Key Differences\n\n1. **Return Value**: Both return a match object if found, or `None` if no match is found.\n\n2. **Flags Support**:\n   - `re` supports all Python's regular expression flags like `re.IGNORECASE`, `re.MULTILINE`, etc.\n   - `re2` supports only a subset of flags: `re2.IGNORECASE`, `re2.MULTILINE`, `re2.DOTALL`, and `re2.UNICODE`.\n\n3. **Backreference Support**:\n   - `re` fully supports backreferences in search patterns.\n   - `re2` doesn't support backreferences in the pattern itself.\n\n### Example\n\n::: {#42c40ef3 .cell execution_count=2}\n``` {.python .cell-code}\nimport re\nimport re2\n\ntext = \"Hello, my email is example@example.com\"\n\n# Using re\nre_result = re.search(r'(\\w+)@(\\w+)\\.com', text)\nif re_result:\n    print(f\"re found: {re_result.group(0)}\")\n    print(f\"Username: {re_result.group(1)}, Domain: {re_result.group(2)}\")\n\n# Using re2\nre2_result = re2.search(r'(\\w+)@(\\w+)\\.com', text)\nif re2_result:\n    print(f\"re2 found: {re2_result.group(0)}\")\n    print(f\"Username: {re2_result.group(1)}, Domain: {re2_result.group(2)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nre found: example@example.com\nUsername: example, Domain: example\nre2 found: example@example.com\nUsername: example, Domain: example\n```\n:::\n:::\n\n\nBoth will output similar results for this simple case, but re2 won't work with patterns containing backreferences like `r'(\\w+)@\\1\\.com'`.\n\n### Option in `re2` is different than `flag` in `re`\n\n::: {#b8a2442c .cell execution_count=3}\n``` {.python .cell-code}\nimport re2\n\ntext = \"Hello, my email is EXAMPLE@example.com\"\n\n# RE2 \n# Create options object with CASE_INSENSITIVE flag\noptions = re2.Options()\noptions.case_sensitive = False\n\n# Pass options as the flags parameter\nmatch = re2.search(r'(\\w+)@(\\w+)\\.com', text, options)\nprint(match.group(0))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEXAMPLE@example.com\n```\n:::\n:::\n\n\n::: {#303f8ba2 .cell execution_count=4}\n``` {.python .cell-code}\noptions.NAMES\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n('max_mem',\n 'encoding',\n 'posix_syntax',\n 'longest_match',\n 'log_errors',\n 'literal',\n 'never_nl',\n 'dot_nl',\n 'never_capture',\n 'case_sensitive',\n 'perl_classes',\n 'word_boundary',\n 'one_line')\n```\n:::\n:::\n\n\n::: {#571c7658 .cell execution_count=5}\n``` {.python .cell-code}\nflags = re.IGNORECASE\n\nif flags is re.IGNORECASE:\n   print(\"IGNORECASE\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGNORECASE\n```\n:::\n:::\n\n\n::: {#85de3ef4 .cell execution_count=6}\n``` {.python .cell-code}\ncombined_flags = re.IGNORECASE | re.MULTILINE  # Value: 10 (binary: 00001010)\n\n# This returns False because combined_flags isn't exactly IGNORECASE\ncombined_flags == re.IGNORECASE  \n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nFalse\n```\n:::\n:::\n\n\n::: {#892e34d8 .cell execution_count=7}\n``` {.python .cell-code}\nif combined_flags & re.IGNORECASE:\n   print(\"IGNORECASE is set\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIGNORECASE is set\n```\n:::\n:::\n\n\n## `findall()`\n\n### Basic API Structure\n\n**`re.findall()`**:\n\n```python\nre.findall(pattern, string, flags=0)\n```\n\n**`re2.findall()`**:\n\n```python\nre2.findall(pattern, string, flags=0)\n```\n\n### Key Differences\n\n1. **Return Value Handling**:\n   - Both return a list of matching strings or tuples (when there are capturing groups).\n   - However, there's a subtle difference in how they handle groups:\n     - With `re`, if there's only one capturing group, you get a list of the contents of that group.\n     - With `re2`, if there's only one capturing group, you still get the full match unless you explicitly use non-capturing groups for the rest.\n\n2. **Performance**: \n   - `re2.findall()` is typically faster for complex patterns on large strings due to re2's linear-time matching guarantees.\n\n### Example\n\n::: {#bf1eba6e .cell execution_count=8}\n``` {.python .cell-code}\nimport re\nimport re2\n\ntext = \"Email me at user1@example.com or user2@test.com\"\nreg_cap = r'(\\w+)@(\\w+)\\.com'\nreg_nc = r'(?:\\w+)@(?:\\w+)\\.com'\n# Using re\nre_result = re.findall(reg_cap, text)\nprint(f\"re findall: {re_result}\") \n\n# Using re2\nre2_result = re2.findall(reg_cap, text)\nprint(f\"re2 findall: {re2_result}\")  # Same result\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nre findall: [('user1', 'example'), ('user2', 'test')]\nre2 findall: [('user1', 'example'), ('user2', 'test')]\n```\n:::\n:::\n\n\nFor patterns with one capturing group, the difference becomes apparent:\n\n::: {#0e26e3d3 .cell execution_count=9}\n``` {.python .cell-code}\nreg_cap = r'(\\w+@\\w+\\.com)'\nreg_nc = r'(?:\\w+@\\w+\\.com)'\n\n# With re\nre_result = re.findall(reg_cap, text)\nprint(f\"re findall: {re_result}\")  # Will return ['user1@example.com', 'user2@test.com']\n\n# With re2\nre2_result = re2.findall(reg_cap, text)\nprint(f\"re2 findall: {re2_result}\")  # Same result, but for different reasons\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nre findall: ['user1@example.com', 'user2@test.com']\nre2 findall: ['user1@example.com', 'user2@test.com']\n```\n:::\n:::\n\n\n## `.finditer()`\n\n### Basic API Structure\n\n**`re.finditer()`**:\n\n```python\nre.finditer(pattern, string, flags=0)\n```\n\n**`re2.finditer()`**:\n\n```python\nre2.finditer(pattern, string, flags=0)\n```\n\n### Key Differences\n\n1. **Return Value**: Both return an iterator yielding match objects.\n\n2. **Match Object Methods**: \n   - `re` match objects have methods like `.start()`, `.end()`, `.span()`, `.group()`, `.groups()`, and `.groupdict()`.\n   - `re2` match objects have the same methods, but some complex operations involving lookahead/lookbehind may behave differently.\n\n3. **Named Group Support**:\n   - Both support named groups with `(?P<name>...)` syntax.\n   - `re2` has limitations with some named group features that `re` supports.\n\n### Example\n\n::: {#44050d65 .cell execution_count=10}\n``` {.python .cell-code}\nimport re\nimport re2\n\ntext = \"Contact us: user1@example.com or user2@test.com\"\n\n# Using re\nfor match in re.finditer(r'(\\w+)@(\\w+)\\.com', text):\n    print(f\"re match: {match.group(0)}, groups: {match.groups()}\")\n    print(f\"  Position: {match.start()}-{match.end()}\")\n\n# Using re2\nfor match in re2.finditer(r'(\\w+)@(\\w+)\\.com', text):\n    print(f\"re2 match: {match.group(0)}, groups: {match.groups()}\")\n    print(f\"  Position: {match.start()}-{match.end()}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nre match: user1@example.com, groups: ('user1', 'example')\n  Position: 12-29\nre match: user2@test.com, groups: ('user2', 'test')\n  Position: 33-47\nre2 match: user1@example.com, groups: ('user1', 'example')\n  Position: 12-29\nre2 match: user2@test.com, groups: ('user2', 'test')\n  Position: 33-47\n```\n:::\n:::\n\n\n# Key Differences Summary\n\n| Feature | `re` module | `re2` module |\n|---------|------------|-------------|\n| **Fundamental Implementation** | Uses backtracking, which can be exponential | Uses finite automata with linear-time guarantees |\n| **Backreferences** | Fully supported | Not supported |\n| **Lookahead/Lookbehind** | Fully supported | Limited support (only fixed-width lookbehind) |\n| **Flag Support** | All standard flags | Limited subset (IGNORECASE, MULTILINE, DOTALL, UNICODE) |\n| **Memory Usage** | Can be high for complex patterns | Generally lower and more predictable |\n| **Performance** | May have catastrophic backtracking on complex patterns | Guaranteed linear time complexity |\n| **Group Handling** | Special handling for single capture group in `findall()` | Consistent behavior |\n\n## Practical Implications\n\n1. **When to use `re2`**:\n   - Processing large text files\n   - When you need performance guarantees (to avoid regex denial-of-service)\n   - When your patterns are relatively simple\n\n2. **When to use `re`**:\n   - When you need backreferences\n   - When you need complex lookahead/lookbehind\n   - For compatibility with existing Python code\n\nRemember that `re2` is designed with safety and performance in mind, specifically to avoid the catastrophic backtracking that can happen with traditional regex engines like the one in Python's `re` module. This comes at the cost of some advanced regex features that cannot be implemented efficiently while maintaining linear-time guarantees.\n\n",
    "supporting": [
      "regex-re2_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}