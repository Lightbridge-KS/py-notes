{
  "hash": "4ddd37420f57026f9fa8afdf297d0b33",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"DataClass\"\n---\n\n\n\n\n\n\n## Intro\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom dataclasses import dataclass, field, asdict, astuple\n\n@dataclass(frozen=True, order=True)\nclass Comment:\n    id: int\n    text: str = \"\"\n    replies: list[int] = field(default_factory=list, repr=False, compare=False)\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nimport attr\n\n@attr.s(frozen=True, order=True, slots=True)\nclass AttrComment:\n    id: int = 0\n    text: str = \"\"\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ncomment_1 = Comment(1, \"I just subscribed!\")\ncomment_2 = Comment(2, \"Hi there\")\n# comment.id = 3  # can't immutable\nprint(comment_1)\n#> Comment(id=1, text='I just subscribed!')\n```\n:::\n\n\n\n\n**To Dict or Tuple**\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nasdict(comment_1)\n#> {'id': 1, 'text': 'I just subscribed!', 'replies': []}\nastuple(comment_1)\n#> (1, 'I just subscribed!', [])\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ncopy = dataclasses.replace(comment, id=3)\n#> NameError: name 'dataclasses' is not defined\nprint(copy)\n#> NameError: name 'copy' is not defined\n\npprint(inspect.getmembers(Comment, inspect.isfunction))\n#> NameError: name 'pprint' is not defined\n```\n:::\n\n\n\n\n### Interitance\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom dataclasses import dataclass\n\n# Define the base dataclass\n@dataclass\nclass Person:\n    name: str\n    age: int\n\n# Define a derived dataclass that inherits from Person\n@dataclass\nclass Employee(Person):\n    employee_id: int\n    department: str\n\n# Create an instance of the derived class\nemployee = Employee(name=\"John Doe\", age=30, employee_id=1234, department=\"Engineering\")\n\n# Display the inherited and new fields\nprint(employee)\n#> Employee(name='John Doe', age=30, employee_id=1234, department='Engineering')\n```\n:::\n\n\n\n\n### Extract each compoent to List\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# List of Comment instances\ncomments = [comment_1, comment_2]\n```\n:::\n\n\n\n\n#### List Comprehension\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Extract the 'id' and 'text' properties into separate lists\nids = [comment.id for comment in comments]\nids\n#> [1, 2]\ntexts = [comment.text for comment in comments]\ntexts\n#> ['I just subscribed!', 'Hi there']\n```\n:::\n\n\n\n\n\n#### Zip with Unpacking\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n[(comment.id, comment.text) for comment in comments]\n#> [(1, 'I just subscribed!'), (2, 'Hi there')]\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Using zip with unpacking\nids, texts = zip(*[(comment.id, comment.text) for comment in comments])\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Convert to list if needed (since zip returns tuples)\nids = list(ids)\ntexts = list(texts)\n```\n:::\n\n\n\n\n#### ðŸ‘‹ To Data Frame\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\nfrom dataclasses import asdict\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ncomments\n#> [Comment(id=1, text='I just subscribed!'), Comment(id=2, text='Hi there')]\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# Convert to a DataFrame\ndf = pd.DataFrame([asdict(comment) for comment in comments])\ndf\n#>    id                text replies\n#> 0   1  I just subscribed!      []\n#> 1   2            Hi there      []\n```\n:::\n\n\n\n\n## Default Argument\n\n### Default Factory\n\nThe `default_factory` argument in the `field()` function within Pythonâ€™s `dataclasses` module is used to provide a default value for a field that is a mutable type, such as a list, dictionary, or set. This is particularly useful because using mutable default arguments (like a list or dictionary) directly in a function or class definition can lead to unintended behavior.\n\n#### Why Use `default_factory`?\n\nIf you define a mutable default argument directly, it can lead to all instances of the class sharing the same object. This is often not what you want. For example:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyClass:\n    my_list: list = []\n#> ValueError: mutable default <class 'list'> for field my_list is not allowed: use default_factory\n\n# All instances share the same list\nobj1 = MyClass()\n#> NameError: name 'MyClass' is not defined\nobj2 = MyClass()\n#> NameError: name 'MyClass' is not defined\nobj1.my_list.append(1)\n#> NameError: name 'obj1' is not defined\nprint(obj2.my_list)  # Output: [1], obj1 and obj2 share the same list!\n#> NameError: name 'obj2' is not defined\n```\n:::\n\n\n\n\nIn contrast, `default_factory` ensures that each instance of the class gets its own independent copy of the mutable object:\n\n#### Example Using `default_factory`:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass MyClass:\n    my_list: list = field(default_factory=list)\n\n# Now, each instance gets its own list\nobj1 = MyClass()\nobj2 = MyClass()\nobj1.my_list.append(1)\nprint(obj2.my_list)  # Output: [], obj1 and obj2 have independent lists\n#> []\n```\n:::\n\n\n\n\n**How It Works:**\n\n- **`default_factory=list`**: This tells Python to call `list()` to create a new empty list each time a new instance of `MyClass` is created.\n- **`default_factory=dict`**: Similarly, this would create a new dictionary for each instance.\n- **`default_factory=lambda: {\"key\": \"value\"}`**: You can also use a lambda function to generate a default value if you need something more complex.\n\n**When to Use It:**\n\nYou should use `default_factory` whenever you need a default value for a field in a data class that is a mutable type. This ensures that each instance of the class gets its own independent copy of the mutable object, avoiding the unintended sharing of state between instances.\n\n**Summary:**\n\n- **`default_factory`** provides a way to specify a factory function that returns a default value for a field.\n- It is especially useful for fields that need a mutable default value (like lists or dictionaries) to ensure each instance of the class gets its own unique object.\n- This helps prevent bugs that occur due to shared mutable defaults across instances of a class.\n\n## Example\n\n### Ex2: Create Simple (Recist) \n\n\nYou can convert the `Recist` class to a `dataclass` in Python by using the `dataclasses` module, which simplifies the creation of classes by automatically generating special methods like `__init__`, `__repr__`, and `__eq__`. Hereâ€™s how you can do it:\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Recist:\n    category: str\n    category_full: str = field(init=False)\n    \n    _category_dict = {\n        \"PR\": \"Partial Response (PR)\",\n        \"CR\": \"Complete Response (CR)\",\n        \"PD\": \"Progressive Disease (PD)\",\n        \"SD\": \"Stable Disease (SD)\"\n    }\n\n    def __post_init__(self):\n        # Set the full category name based on the provided short category\n        if self.category in self._category_dict:\n            self.category_full = self._category_dict[self.category]\n        else:\n            raise ValueError(f\"Unknown category: {self.category}\")\n```\n:::\n\n\n\n\n**Explanation:**\n\n- **`@dataclass` Decorator:** This decorator is used to create a data class, which automatically generates the `__init__` method and other utility methods based on the fields you define.\n- **Fields:**\n  - `category`: This is the input field where you pass the short form of the RECIST category.\n  - `category_full`: This field is automatically computed based on the `category` and does not need to be initialized by the user. It is marked with `field(init=False)` to exclude it from the generated `__init__` method.\n- **`__post_init__` Method:** This special method is automatically called after the `__init__` method. It's used here to set `category_full` based on the provided `category` value. If the `category` is not in the `_category_dict`, an exception is raised.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Creating an instance of the Recist class\nrecist_instance = Recist(category=\"PR\")\nprint(recist_instance.category)       # Output: \"PR\"\n#> PR\nprint(recist_instance.category_full)  # Output: \"Partial Response (PR)\"\n#> Partial Response (PR)\n\n# Handling an invalid category\ntry:\n    invalid_instance = Recist(category=\"XX\")\nexcept ValueError as e:\n    print(e)  # Output: \"Unknown category: XX\"\n#> Unknown category: XX\n```\n:::\n",
    "supporting": [
      "dataclass_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}