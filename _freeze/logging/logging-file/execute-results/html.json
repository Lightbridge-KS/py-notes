{
  "hash": "b72b3ffd2e164df87996958db8709f99",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Logging (to file)\"\n---\n\n\n\n\n::: {.callout-note appearance=\"minimal\"}\nQ: How to log a warning message of a given custom function to a log file?\n:::\n\n## Log Single to File\n\nTo log a **warning message** from a custom function to a log file, you can use Python's built-in `logging` module. Here's how you can set it up step-by-step:\n\n1. **Set Up Logging Configuration**\n- The `logging` module allows you to log messages at different levels (e.g., DEBUG, INFO, WARNING, ERROR). You can configure it to log messages to a file.\n\n2. **Log a Warning in a Custom Function**\n- Define your function and log a warning when necessary.\n\n::: {#52f90f9d .cell execution_count=1}\n``` {.python .cell-code}\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    filename=\"app.log\",  # Log file name\n    level=logging.WARNING,  # Log level\n    format=\"%(asctime)s - %(levelname)s - %(message)s\"  # Log format\n)\n\ndef custom_function(param):\n    \"\"\"Example custom function that logs a warning.\"\"\"\n    if param < 0:\n        logging.warning(f\"Received negative value: {param}\")\n        return \"Invalid input\"\n    else:\n        return f\"Processed value: {param}\"\n\n# Example usage\ncustom_function(10)  # No warning logged\ncustom_function(-4)  # Logs a warning\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n'Invalid input'\n```\n:::\n:::\n\n\nWhen `custom_function(-5)` is called, the following entry is logged in `app.log`:\n\n```\n2024-11-23 12:00:00,123 - WARNING - Received negative value: -5\n```\n\n**Explanation**:\n\n1. **Logging Configuration**:\n   \n   - `filename=\"app.log\"`: Logs are written to a file named `app.log`.\n   - `level=logging.WARNING`: Only logs messages of level WARNING or higher (e.g., ERROR).\n   - `format=\"...\"`: Specifies the log format, including timestamp, log level, and message.\n\n2. **Logging in the Function**:\n   \n   - The `logging.warning()` method logs a message at the WARNING level.\n   - Custom messages are added dynamically based on the function's logic.\n\n## Log Wrapper to Multiple Files\n\n\nTo achieve logging to a new file with a timestamped filename each time `wrapper_function()` runs, you can dynamically configure the logging setup in `wrapper_function()` before calling `custom_function()` in a loop.\n\n---\n\n**Implementation Steps**:\n\n1. Generate a unique timestamp for the log file each time `wrapper_function()` is run.\n2. Configure the logging to output messages to `log/app-<timestamp>.log`.\n3. Inside the loop, call `custom_function()` and log messages for each iteration using the configured logging setup.\n4. Use the same logging format as before.\n\n---\n\n::: {#f3c56f76 .cell execution_count=2}\n``` {.python .cell-code}\nimport logging\nimport os\nfrom datetime import datetime\n\n# Custom function to be wrapped\ndef custom_function(param):\n    \"\"\"Logs a warning if param is negative.\"\"\"\n    if param < 0:\n        logging.warning(f\"Received negative value: {param}\")\n        return \"Invalid input\"\n    else:\n        return f\"Processed value: {param}\"\n\n# Logging setup function\ndef _get_log_file():\n    \"\"\"Sets up logging for wrapper_function with a timestamped log file.\"\"\"\n    # Create a timestamped log file name\n    timestamp = datetime.now().strftime(\"%Y-%m-%d_%H%M%S\")\n    log_dir = \"log\"\n    os.makedirs(log_dir, exist_ok=True)  # Ensure the log directory exists\n    log_file = os.path.join(log_dir, f\"app-{timestamp}.log\")\n\n    # Create a logger\n    logger = logging.getLogger(\"custom_logger\")\n    logger.setLevel(logging.WARNING)\n\n    # Clear any existing handlers\n    if logger.hasHandlers():\n        logger.handlers.clear()\n\n    # Create a file handler\n    file_handler = logging.FileHandler(log_file)\n    file_handler.setLevel(logging.WARNING)\n\n    # Set the logging format\n    formatter = logging.Formatter(\"%(asctime)s - %(levelname)s - %(message)s\")\n    file_handler.setFormatter(formatter)\n\n    # Add the handler to the logger\n    logger.addHandler(file_handler)\n\n    # Return the logger instance and log file path\n    return logger, log_file\n\n# Wrapper function\ndef wrapper_function(params):\n    \"\"\"Wrapper function that runs custom_function in a loop.\"\"\"\n    logger, log_file = _get_log_file()  # Set up logging\n    for param in params:\n        result = custom_function(param)  # Call custom_function\n        if \"Invalid\" in result:  # Log result if it's a warning\n            logger.warning(f\"Result: {result}\")\n    print(f\"Warnings for this run are saved in {log_file}\")\n```\n:::\n\n\n::: {#75614e4c .cell execution_count=3}\n``` {.python .cell-code}\ncustom_function(-1)\ncustom_function(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n'Processed value: 1'\n```\n:::\n:::\n\n\n::: {#c73273f8 .cell execution_count=4}\n``` {.python .cell-code}\nparams = [10, -5, -3, 20]\nwrapper_function(params)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWarnings for this run are saved in log/app-2025-02-12_200540.log\n```\n:::\n:::\n\n\n**Explanation**:\n\n1. **Dynamic Log File Creation**:\n   - `datetime.now().strftime(\"%Y%m%d-%H%M%S\")` generates a timestamp in the format `YYYYMMDD-HHMMSS` for the log file.\n   - A new log file (`app-<timestamp>.log`) is created inside the `log/` directory every time `wrapper_function()` runs.\n\n2. **Logging Configuration**:\n   - `logging.basicConfig()` is called inside `wrapper_function()` to configure logging dynamically for the current run.\n   - The `filemode=\"w\"` ensures that each log file starts fresh for each run.\n\n3. **Iterative Logging**:\n   - Inside the loop, `custom_function()` logs messages for each parameter, which are written to the timestamped log file.\n\n4. **Directory Management**:\n   - The `os.makedirs(log_dir, exist_ok=True)` ensures the `log/` directory exists. If it doesnâ€™t, it is created automatically.\n\n\n\n### Example Output\n\n**Log File Path**:\n\nFor a run on `2024-11-23` at `15:45:30`, the log file would be saved as:\n```\nlog/app-20241123-154530.log\n```\n\n**Log File Content**:\n\nInside `log/app-20241123-154530.log`, you would see:\n```\n2024-11-23 15:45:30,123 - INFO - Processed value: 10\n2024-11-23 15:45:30,124 - WARNING - Received negative value: -5\n2024-11-23 15:45:30,125 - INFO - Processed value: 0\n2024-11-23 15:45:30,126 - INFO - Processed value: 20\n2024-11-23 15:45:30,127 - INFO - Result: Processed value: 10\n2024-11-23 15:45:30,128 - INFO - Result: Invalid input\n2024-11-23 15:45:30,129 - INFO - Result: Processed value: 0\n2024-11-23 15:45:30,130 - INFO - Result: Processed value: 20\n```\n\n## Capture Warning\n\n::: {#06de9e0e .cell execution_count=5}\n``` {.python .cell-code}\nimport warnings\n\n# Child function that issues warnings\ndef child_fn(param):\n    if param < 0:\n        warnings.warn(f\"Received negative value: {param}\", UserWarning)\n    else:\n        warnings.warn(f\"Processed value: {param}\", UserWarning)\n\n# Parent function that checks if warnings are issued\ndef parent_fn(param):\n    with warnings.catch_warnings(record=True) as caught_warnings:\n        warnings.simplefilter(\"always\")  # Ensure all warnings are captured\n        child_fn(param)  # Call the child function\n        \n        # Check if any warnings were issued\n        if caught_warnings:\n            print(\"Warning detected!\")\n            for warning in caught_warnings:\n                print(f\"Captured warning: {warning.message}\")\n        else:\n            print(\"No warnings issued.\")\n```\n:::\n\n\n::: {#777a831e .cell execution_count=6}\n``` {.python .cell-code}\nparent_fn(-5)  # Should capture a warning\nparent_fn(10)  # Should capture a warning\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nWarning detected!\nCaptured warning: Received negative value: -5\nWarning detected!\nCaptured warning: Processed value: 10\n```\n:::\n:::\n\n\n",
    "supporting": [
      "logging-file_files"
    ],
    "filters": [],
    "includes": {}
  }
}