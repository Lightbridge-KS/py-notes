{
  "hash": "d1d53f506629a69ab0901bcdd86e6a5b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Comprehension & Others\"\n---\n\n\n\n\n\n\n\n## List Comprehension\n\n### Syntax\n\n```python\n[expression for item in iterable if condition]\n```\n\n**Longer version:**\n\n\n::: {.panel-tabset}\n#### Comprehension\n\n```python\n[expression for item1 in iterable1 if condition1\n            for item2 in iterable2 if condition2\n            ...\n            for itemN in iterableN if conditionN ]\n```\n#### For Loop\n\n```python\nresult = []\nfor item1 in iterable1:\n    if condition1:\n        for item2 in iterable2:\n           if condition2:\n               ...\n               for itemN in iterableN:\n                   if conditionN:\n                       result.append(expression)\n```\n\n:::\n\n### Basic\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnums = [1, 2, 3, 4, 5]\nsquares = [n * n for n in nums]\nsquares\n#> [1, 4, 9, 16, 25]\n```\n:::\n\n\n\n\n**Comprehension with filter**\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnumbers = [1, 2, 3, 4, 5]\n[n ** 2 for n in numbers if n % 2 == 0] \n#> [4, 16]\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nls = [\"a\", \"b\", \"c\"]\n\n# Equivalent\n[x.upper() for x in ls]\n#> ['A', 'B', 'C']\n[str.upper(x) for x in ls]\n#> ['A', 'B', 'C']\n```\n:::\n\n\n\n\n### Multiline Comprehension\n\nFor readibility:\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef double_short_words(words):\n    return [\n        word + word\n        for word in words\n        if len(word) < 5\n    ]\n```\n:::\n\n\n\n\n### Nested Compreshension\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncolors = [\"orange\", \"purple\", \"pink\"]\ntoys = [\"bike\", \"basketball\", \"skateboard\", \"doll\"]\n\n[ color + \" \" + toy\n  for color in colors\n  for toy in toys ]\n#> ['orange bike', 'orange basketball', 'orange skateboard', 'orange doll', 'purple bike', 'purple basketball', 'purple skateboard', 'purple doll', 'pink bike', 'pink basketball', 'pink skateboard', 'pink doll']\n```\n:::\n\n\n\n\n### Using `_` varible\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nd = [1, 2]\nl = [list(d) for _ in d]\nl\n#> [[1, 2], [1, 2]]\n```\n:::\n\n\n\n\n### Ex 1: List of Dict\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nportfolio = [\n  {'name': 'IBM', 'shares': 100, 'price': 91.1 },\n  {'name': 'MSFT', 'shares': 50, 'price': 45.67 },\n  {'name': 'HPE', 'shares': 75, 'price': 34.51 },\n  {'name': 'CAT', 'shares': 60, 'price': 67.89 },\n  {'name': 'IBM', 'shares': 200, 'price': 95.25 }\n]\n```\n:::\n\n\n\n\nCollect all names\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnames = [s['name'] for s in portfolio]\nnames\n#> ['IBM', 'MSFT', 'HPE', 'CAT', 'IBM']\n```\n:::\n\n\n\n\nFind all entries with more than 100 shares ['IBM']\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmore100 = [s['name'] for s in portfolio if s['shares'] > 100 ]\nmore100\n#> ['IBM']\n```\n:::\n\n\n\n\nFind the total shares*price\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncost = sum([s['shares']*s['price'] for s in portfolio])\ncost\n#> 37105.15\n```\n:::\n\n\n\n\nCollect (name, shares) tuples\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nname_shares = [ (s['name'], s['shares']) for s in portfolio ] \nname_shares\n#> [('IBM', 100), ('MSFT', 50), ('HPE', 75), ('CAT', 60), ('IBM', 200)]\n```\n:::\n\n\n\n\n### Ex 2: Wrapping Function\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef toint(x):\n    try:\n        return int(x)\n    except ValueError:\n        return None\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nvalues = [ '1', '2', '-4', 'n/a', '-3', '5' ]\n\ndata1 = [ toint(x) for x in values ]\nprint(data1)\n#> [1, 2, -4, None, -3, 5]\n\ndata2 = [ toint(x) for x in values if toint(x) is not None ]\nprint(data2)\n#> [1, 2, -4, -3, 5]\n```\n:::\n\n\n\n\nUsing `:=`\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndata3 = [ v for x in values if (v:=toint(x)) is not None ]\nprint(data3)\n#> [1, 2, -4, -3, 5]\n\ndata4 = [ v for x in values if (v:=toint(x)) is not None and v >= 0 ]\nprint(data4)\n#> [1, 2, 5]\n```\n:::\n\n\n\n\n\n\n## Set & Dict Comprehension\n\n### Set Comprehension\n\nA set of distinct values\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# Set comprehension\nnames = { s['name'] for s in portfolio }\nnames\n#> {'HPE', 'MSFT', 'CAT', 'IBM'}\n```\n:::\n\n\n\n\n### Dict Comprehension\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nprices = { s['name']:s['price'] for s in portfolio }\nprices\n#> {'IBM': 95.25, 'MSFT': 45.67, 'HPE': 34.51, 'CAT': 67.89}\n```\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\ndd = {\"a\": \"aa\", \"b\": \"bb\"}\n\n{k: v for k, v in dd.items()} # Dict\n#> {'a': 'aa', 'b': 'bb'}\n[k for k in dd.keys()] # Keys\n#> ['a', 'b']\n[v for v in dd.values()] # Values\n#> ['aa', 'bb']\n```\n:::\n\n\n\n\n\n## `map()` Function\n\n`map(function, iterable)`\n\n`map()` applies a function to all the items in an input list. It returns a map object (an iterator) of the results after applying the given function to each item of the given iterable (list, tuple etc.).\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnumbers = [1, 2, 3, 4, 5]\nsquares = map(lambda x: x**2, numbers)  \nlist(squares)  # Converting the map object to a list\n#> [1, 4, 9, 16, 25]\n```\n:::\n\n\n\n\n## Differences and When to Use\n\n- **Readability**: List comprehensions are often more readable and succinct, especially for simple operations or when filtering conditions are involved.\n- **Performance**: Both list comprehensions and `map()` are faster than a for loop. However, for very large data sets, `map()` can be more memory-efficient (since it returns an iterator), but the difference is often negligible.\n- **Function Application**: If you're applying an existing function (especially a more complex one), `map()` can be more convenient. For operations that can be expressed as a single expression, or where you need conditional logic (like filtering), a list comprehension is often the better choice.\n- **Return Type**: `map()` returns a map object (iterator), which you often need to convert back to a list or another iterable type. List comprehensions return a list directly.\n\nIn summary, use list comprehensions when you need a readable and concise way to generate a new list by applying an expression to each item in an iterable, possibly with filtering. Use `map()` when you need to apply an already-defined function to each item in an iterable and are okay with receiving an iterator as the result.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}