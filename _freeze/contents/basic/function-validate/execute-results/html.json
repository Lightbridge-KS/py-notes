{
  "hash": "253a19841d5dd03fd05aceb0fd6787de",
  "result": {
    "engine": "jupyter",
    "markdown": "# Function (Validation)\n\n\n## My Arguments Validation\n\nI would use these balanced approach:\n\n::: {#28364ad4 .cell execution_count=1}\n``` {.python .cell-code}\nfrom typing import Literal\n\ndef fn1(a: Literal[\"apple\", \"banana\", \"orange\"]):\n\n    valid_fruits = frozenset({\"apple\", \"banana\", \"orange\"})\n\n    if a not in valid_fruits:\n        raise ValueError(f\"Invalid value: {a}. Must be one of: {', '.join(valid_fruits)}\")\n    # Rest of the function\n    return a\n```\n:::\n\n\n::: {#52da0f6e .cell execution_count=2}\n``` {.python .cell-code}\nfn1(\"apple\")\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n'apple'\n```\n:::\n:::\n\n\n::: {#3377778e .cell execution_count=3}\n``` {.python .cell-code}\ntry:\n    fn1(\"watermelon\")\nexcept ValueError as e:\n    print(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInvalid value: watermelon. Must be one of: orange, apple, banana\n```\n:::\n:::\n\n\n## Arguments Validation (Approach)\n\n::: {.callout-note appearance=\"minimal\" collapse=\"false\"}\nQ: If I have a function, say, `fn1(a)`,  which have an argument `a` with only 3 possible text values: \"apple\", \"banana\", \"orange\". \n\nGive me different approach to perform arguments validation.\n:::\n\nI'll help you explore different approaches to validate function arguments when there are only specific allowed values. Let's examine various methods, starting from simple to more sophisticated approaches.\n\n### If-else statements (Basic Approach):\n\n::: {#6628a0c6 .cell execution_count=4}\n``` {.python .cell-code}\ndef fn1(a):\n    if a not in [\"apple\", \"banana\", \"orange\"]:\n        raise ValueError(f\"Invalid value: {a}. Must be one of: apple, banana, orange\")\n    # Rest of the function\n    return a\n```\n:::\n\n\n### Using an Enum class (Type Safety)\n\n::: {#6573b1a2 .cell execution_count=5}\n``` {.python .cell-code}\nfrom enum import Enum, auto\n\nclass Fruit(Enum):\n    APPLE = \"apple\"\n    BANANA = \"banana\"\n    ORANGE = \"orange\"\n\ndef fn1(a: Fruit) -> str:\n    # The type hint ensures only Fruit enum values are accepted\n    return a.value\n```\n:::\n\n\n### Using a Set for faster lookup:\n\n::: {#10d5e0bf .cell execution_count=6}\n``` {.python .cell-code}\nVALID_FRUITS = frozenset({\"apple\", \"banana\", \"orange\"})\n\ndef fn1(a: str) -> str:\n    if a not in VALID_FRUITS:\n        raise ValueError(f\"Invalid value: {a}. Must be one of: {', '.join(VALID_FRUITS)}\")\n    return a\n```\n:::\n\n\n### Using decorators (Advanced):\n\n::: {#632c87c8 .cell execution_count=7}\n``` {.python .cell-code}\nfrom functools import wraps\nfrom typing import Callable, Any\n\ndef validate_fruit(func: Callable) -> Callable:\n    valid_fruits = frozenset({\"apple\", \"banana\", \"orange\"})\n    \n    @wraps(func)\n    def wrapper(a: str, *args: Any, **kwargs: Any) -> Any:\n        if a not in valid_fruits:\n            raise ValueError(f\"Invalid value: {a}. Must be one of: {', '.join(valid_fruits)}\")\n        return func(a, *args, **kwargs)\n    \n    return wrapper\n\n@validate_fruit\ndef fn1(a: str) -> str:\n    return a\n```\n:::\n\n\n::: {#b707e156 .cell execution_count=8}\n``` {.python .cell-code}\ntry:\n    fn1(\"watermelon\")\nexcept ValueError as e:\n    print(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInvalid value: watermelon. Must be one of: orange, apple, banana\n```\n:::\n:::\n\n\n### Using Literal type hints (Python 3.8+):\n\n::: {#48ebd026 .cell execution_count=9}\n``` {.python .cell-code}\nfrom typing import Literal\n\ndef fn1(a: Literal[\"apple\", \"banana\", \"orange\"]) -> str:\n    return a\n```\n:::\n\n\n::: {#c97a7c4e .cell execution_count=10}\n``` {.python .cell-code}\nfn1(\"watermelon\")\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n'watermelon'\n```\n:::\n:::\n\n\nLet me explain the pros and cons of each approach:\n\nThe if-else approach is straightforward and easy to understand, but it's verbose if you need to reuse the validation in multiple functions.\n\nThe Enum approach provides type safety and IDE support, making it harder to make mistakes. It's especially useful in larger applications where you want to ensure type consistency. However, it requires more setup code.\n\nThe Set approach offers faster lookup times compared to lists and is memory efficient. It's a good balance between simplicity and performance, especially when you have many valid values.\n\nThe decorator approach allows you to separate the validation logic from the function implementation, making it reusable across multiple functions. However, it's more complex and might be overkill for simple cases.\n\nThe Literal type hints provide static type checking if you use a type checker like mypy, but they don't enforce runtime validation by themselves. They're great for documentation and catching errors during development.\n\nFor your specific case, since you mentioned you're at an intermediate Python level, I would recommend either the Set approach or the Enum approach:\n\n- Use the Set approach if you want something simple and performant\n- Use the Enum approach if you want better type safety and IDE support\n\nWould you like me to elaborate on any of these approaches or show you how to combine them for more robust validation?\n\n",
    "supporting": [
      "function-validate_files"
    ],
    "filters": [],
    "includes": {}
  }
}