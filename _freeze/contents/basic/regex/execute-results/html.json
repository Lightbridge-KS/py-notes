{
  "hash": "a5501181364bf508d8208de93f9ad537",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Regex\n---\n\n::: {#240042be .cell execution_count=1}\n``` {.python .cell-code}\nimport re\n```\n:::\n\n\n## Common Functions \n\n### `re.search()`\n\n- Searches for the first occurrence of a pattern within a string.\n- Returns a match object if the pattern is found; otherwise, returns `None`.\n\n::: {#35a6094a .cell execution_count=2}\n``` {.python .cell-code}\nimport re\n\ntext = \"hello world\"\nmatch = re.search(r\"hello\", text)\nprint(match)\n\nif match:\n    print(\"Pattern found!\")\nelse:\n    print(\"Pattern not found.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<re.Match object; span=(0, 5), match='hello'>\nPattern found!\n```\n:::\n:::\n\n\n### `re.match()`\n\n- Checks if the pattern matches **at the beginning** of the string.\n- Returns a match object if it matches the start of the string, otherwise returns `None`.\n\n::: {#e5e50c6d .cell execution_count=3}\n``` {.python .cell-code}\ntext = \"hello world\"\nmatch = re.match(r\"hello\", text)\n\nif match:\n    print(\"Pattern matches the start!\")\nelse:\n    print(\"No match at the start.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPattern matches the start!\n```\n:::\n:::\n\n\n### `re.findall()`\n\n::: {#14d78ab1 .cell execution_count=4}\n``` {.python .cell-code}\ntext = \"My phone number is 1234, and my zip code is 56789.\"\nmatches = re.findall(r\"\\d+\", text)\nmatches\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n['1234', '56789']\n```\n:::\n:::\n\n\n### `re.sub()`\n\n- Substitutes all occurrences of a pattern with a replacement string.\n- Returns a new string with the substitutions.\n\n::: {#0f690f24 .cell execution_count=5}\n``` {.python .cell-code}\ntext = \"I have a dog. My neighbor has a dog too.\"\nnew_text = re.sub(r\"dog\", \"cat\", text)\nnew_text\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\n'I have a cat. My neighbor has a cat too.'\n```\n:::\n:::\n\n\n## Regex Syntax\n\nRegular expressions use **special characters** to define patterns. Here are some of the most commonly used characters:\n\n### Metacharacters:\n\n- `.` : Matches any single character except newline (`\\n`).\n- `^` : Matches the start of a string.\n- `$` : Matches the end of a string.\n- `*` : Matches 0 or more repetitions of the preceding character.\n- `+` : Matches 1 or more repetitions of the preceding character.\n- `?` : Matches 0 or 1 occurrence of the preceding character.\n- `{}` : Specifies the number of repetitions (e.g., `{2}` means exactly two, `{2,4}` means between two and four).\n\n\n### Character Classes:\n\n- `\\d` : Matches any digit (equivalent to `[0-9]`).\n- `\\w` : Matches any alphanumeric character (equivalent to `[a-zA-Z0-9_]`).\n- `\\s` : Matches any whitespace character (spaces, tabs, newlines).\n- `\\D`, `\\W`, `\\S` : Match the opposite of `\\d`, `\\w`, and `\\s`.\n\n\n### Anchors:\n\n- `^` : Anchors the pattern to the start of the string.\n- `$` : Anchors the pattern to the end of the string.\n\nExample:\n```python\npattern = r\"^\\d+\"  # Matches digits at the start of the string\ntext = \"1234abc\"\nmatch = re.search(pattern, text)\nif match:\n    print(\"Found at the start:\", match.group())  # Output: Found at the start: 1234\n```\n\n### Groups:\n\n- Parentheses `()` are used to create groups in regex.\n- You can extract matched groups using `.group()` or `.groups()`.\n\nExample:\n\n::: {#b118f5fb .cell execution_count=6}\n``` {.python .cell-code}\npattern = r\"(hello) (world)\"\ntext = \"hello world\"\nmatch = re.search(pattern, text)\n\nif match:\n    print(match.group(1))  # Output: hello\n    print(match.group(2))  # Output: world\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello\nworld\n```\n:::\n:::\n\n\n### Escaping Special Characters\n\nIf you want to match one of the special regex characters literally, you need to escape it using a backslash (`\\`).\n\nExample:\n\n::: {#b517254b .cell execution_count=7}\n``` {.python .cell-code}\npattern = r\"\\$100\"  # Matches the string \"$100\"\ntext = \"The price is $100.\"\nmatch = re.search(pattern, text)\n\nif match:\n    print(\"Price found:\", match.group()) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrice found: $100\n```\n:::\n:::\n\n\n### Flags in Regex\n\nYou can modify the behavior of regex with flags, such as:\n- `re.IGNORECASE` or `re.I` : Makes the regex case-insensitive.\n- `re.MULTILINE` or `re.M` : Allows `^` and `$` to match the start and end of each line in a multi-line string.\n- `re.DOTALL` or `re.S` : Makes `.` match newlines as well.\n\n::: {#ccbf20db .cell execution_count=8}\n``` {.python .cell-code}\npattern = r\"hello\"\ntext = \"HELLO world\"\nmatch = re.search(pattern, text, re.IGNORECASE)\n\nif match:\n    print(\"Case-insensitive match found!\") \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCase-insensitive match found!\n```\n:::\n:::\n\n\n## Use Cases\n\n### No Match - Exception\n\n`if match is None`\n\n::: {#5f162b99 .cell execution_count=9}\n``` {.python .cell-code}\nclass Money:\n    def __init__(self, dollars, cents):\n        self.dollars = dollars\n        self.cents = cents\n    def __repr__(self):\n        return f\"Money({self.dollars}, {self.cents})\"\n```\n:::\n\n\n::: {#69fb7ff2 .cell execution_count=10}\n``` {.python .cell-code}\nimport re\ndef money_from_string(amount):\n    match = re.search(\n        r'^\\$(?P<dollars>\\d+)\\.(?P<cents>\\d\\d)$', amount)\n    # Adding the next two lines here\n    if match is None:\n        raise ValueError(f\"Invalid amount: {amount}\")\n    dollars = int(match.group('dollars'))\n    cents = int(match.group('cents'))\n    return Money(dollars, cents)\n```\n:::\n\n\n::: {#31c17868 .cell execution_count=11}\n``` {.python .cell-code}\nmoney_from_string(\"$12.34\")\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nMoney(12, 34)\n```\n:::\n:::\n\n\n::: {#8b23fd3d .cell execution_count=12}\n``` {.python .cell-code}\ntry:\n    money_from_string(\"Big\")\nexcept ValueError as e:\n    print(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nInvalid amount: Big\n```\n:::\n:::\n\n\n## `re` vs `regex`\n\n::: {#1334689e .cell execution_count=13}\n``` {.python .cell-code}\nimport re\nimport regex\nimport timeit\n\ntext = \"hello world\" * 1000000\npattern = r'world'\n\n# re module\ndef re_search():\n    return len(re.findall(pattern, text))\n\n# regex module\ndef regex_search():\n    return len(regex.findall(pattern, text))\n```\n:::\n\n\n::: {#477497ea .cell execution_count=14}\n``` {.python .cell-code}\n# Benchmark\nprint(\"re module:\", timeit.timeit(re_search, number=100))\nprint(\"regex module:\", timeit.timeit(regex_search, number=100))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nre module: 2.7286510409903713\nregex module: 10.390523624955676\n```\n:::\n:::\n\n\n## Fuzzy Matching\n\nLet me explain fuzzy matching through a practical example that you might encounter in medical records.\n\nImagine you're working with patient names in a database. With regular exact matching, searching for \"Johnson\" would only find \"Johnson\" - it wouldn't find common variations or typos like \"Johnsen\", \"Jonson\", or \"Johnson\". This is where fuzzy matching comes in.\n\nFuzzy matching is a technique that finds strings that approximately match a pattern, even when they're not exactly the same. It measures how similar two strings are and can match them if they're \"close enough.\" This is especially useful when dealing with:\n\n1. Misspellings: Like matching \"penicillin\" with \"penicilin\"\n2. Name variations: Like matching \"Catherine\" with \"Katherine\"\n3. OCR errors: When scanned text isn't perfectly recognized\n4. Data entry errors: When humans make typing mistakes\n\nHere's a practical example using Python's `regex` module with fuzzy matching:\n\n::: {#9c38637f .cell execution_count=15}\n``` {.python .cell-code}\nimport regex\n\n# Regular exact matching\ntext = \"The patient Smith was prescribed penicillin\"\nexact_pattern = r'penicillin'\nprint(\"Exact match:\", regex.findall(exact_pattern, text))  # Finds 'penicillin'\n\n# Fuzzy matching with maximum 2 differences allowed\nfuzzy_pattern = r'(?:penicillin){e<=2}'  # e<=2 means allow up to 2 errors\ntexts = [\n    \"The patient Smith was prescribed penicilin\",   # Missing 'l'\n    \"The patient Smith was prescribed peniciilin\",  # Extra 'i'\n    \"The patient Smith was prescribed penicilln\"    # Missing 'i'\n]\n\nfor t in texts:\n    matches = regex.findall(fuzzy_pattern, t)\n    print(f\"Fuzzy matches in '{t}': {matches}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExact match: ['penicillin']\nFuzzy matches in 'The patient Smith was prescribed penicilin': [' penicilin']\nFuzzy matches in 'The patient Smith was prescribed peniciilin': [' peniciilin']\nFuzzy matches in 'The patient Smith was prescribed penicilln': [' penicilln']\n```\n:::\n:::\n\n\nThe magic happens in how fuzzy matching calculates the \"distance\" between strings. The most common method is Levenshtein distance, which counts the minimum number of single-character edits needed to change one string into another. For example:\n\n- \"penicillin\" → \"penicilin\" (distance = 1, one deletion)\n- \"Smith\" → \"Smyth\" (distance = 1, one substitution)\n- \"Katherine\" → \"Catherine\" (distance = 1, one substitution)\n\nThink of it like measuring how many steps it takes to transform one word into another, where each step can be:\n- Inserting a character\n- Deleting a character\n- Substituting one character for another\n\nThis is particularly valuable in medical contexts where accuracy is crucial but variations are common. For instance, when searching through medical records, fuzzy matching could help you find relevant cases even when drug names or conditions are slightly misspelled.\n\n",
    "supporting": [
      "regex_files"
    ],
    "filters": [],
    "includes": {}
  }
}