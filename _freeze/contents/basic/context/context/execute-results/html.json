{
  "hash": "53c9bd46b2453eedbadba51f68eee443",
  "result": {
    "engine": "jupyter",
    "markdown": "# Context Manager\n\n<!-- ```{r}\n#| include: false\nlibrary(here)\nhere::i_am(\"basic/context/context.qmd\")\nsource(here(\"_common.R\"))\n``` -->\n\n\n[Python `with` statement (realpython)](https://realpython.com/python-with-statement/)\n\n::: {#70d7df09 .cell execution_count=1}\n``` {.python .cell-code}\nfrom pathlib import Path\n```\n:::\n\n\nAbout `cwd()`\n\n- In Quarto or Jupyter it is the directory that .qmd or .ipynb in.\n- In Python script it is the project root (where the terminal was run)\n\n::: {#ffd1ebd8 .cell execution_count=2}\n``` {.python .cell-code}\nPath().cwd() # Check WD\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\nPosixPath('/Users/kittipos/my_book/py-notes/contents/basic/context')\n```\n:::\n:::\n\n\n## Write file (Error Prone)\n\n::: {#39511b2d .cell execution_count=3}\n``` {.python .cell-code}\nfile = open(\"hello.txt\", \"w\")\nfile.write(\"Hello, World!\")\nfile.close()\n```\n:::\n\n\nTo improve ...\n\nIn Python, you can use two general approaches to deal with resource management. You can wrap your code in:\n\n- **A `try ‚Ä¶ finally` construct** (more general)\n\n- **A `with` construct** (more concise)\n    - Works only objects that support the context management protocol\n\n## Write file (`try ... finally`)\n\n::: {#632de2ae .cell execution_count=4}\n``` {.python .cell-code}\n# Safely open the file\nfile = open(\"hello.txt\", \"w\")\n\ntry:\n    file.write(\"Hello, World!\")\nexcept Exception as e:\n    print(f\"An error occurred while writing to the file: {e}\")\nfinally:\n    # Make sure to close the file after using it\n    file.close()\n```\n:::\n\n\n## Write file (`with` Statement)\n\n### Simple\n\n```python\nwith expression as target_var:\n    do_something(target_var)\n```\n\n`expression` must return an object that implements the context management protocol. This protocol consists of two special methods:\n\n- `.__enter__()` is called by the with statement to enter the runtime context.\n- `.__exit__()` is called when the execution leaves the with code block.\n\n::: {#b920692f .cell execution_count=5}\n``` {.python .cell-code}\nwith open(\"hello.txt\", mode=\"w\") as file:\n    file.write(\"Hello, World!\")\n```\n:::\n\n\nWhen you run this with statement, `open()` returns an `io.TextIOBase` object. This object is also a context manager, so the with statement calls .__enter__() and assigns its return value to file. Then you can manipulate the file inside the with code block. When the block ends, .__exit__() automatically gets called and closes the file for you, even if an exception is raised inside the with block.\n\n### Multiple\n\nmultiple context managers \n\n```python\nwith A() as a, B() as b:\n    pass\n```\n\n```python\nwith open(\"input.txt\") as in_file, open(\"output.txt\", \"w\") as out_file:\n    # Read content from input.txt\n    # Transform the content\n    # Write the transformed content to output.txt\n    pass\n```\n\n### üëç Better (pathlib)\n\nyou should consider using `Path.open()` in your with statements as a best practice in Python.\n\n::: {#9937e3ec .cell execution_count=6}\n``` {.python .cell-code}\nfrom pathlib import Path\n\nwith Path(\"hello.txt\").open(\"w\") as file:\n    file.write(\"Hello, World!\")\n```\n:::\n\n\nIn this example, you wrap the with statement in a try ‚Ä¶ except statement. If an OSError occurs during the execution of with, then you use logging to log the error with a user-friendly and descriptive message.\n\n::: {#f5d4d2ff .cell execution_count=7}\n``` {.python .cell-code}\nimport pathlib\nimport logging\n\nfile_path = pathlib.Path(\"hellos.txt\")\n\ntry:\n    with file_path.open(mode=\"w\") as file:\n        file.write(\"Hello, World!\")\nexcept OSError as error:\n    logging.error(\"Writing to file %s failed due to: %s\", file_path, error)\n```\n:::\n\n\n",
    "supporting": [
      "context_files"
    ],
    "filters": [],
    "includes": {}
  }
}