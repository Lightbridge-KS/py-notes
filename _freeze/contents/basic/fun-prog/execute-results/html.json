{
  "hash": "3c74ef48255787446fe69e8e0d8f8d41",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Functional Programming\"\n---\n\n\n\n\n## Compared to `{purrr}`\n\nFunctional programming in Python, compared to `{purrr}` package in R.\n\n### `map()`\n\nIn R, `purrr::map()` applies a function to each element of a list and returns a list. In Python, the built-in `map()` function achieves this.\n\n`R`:\n\n```R\nlibrary(purrr)\nmap(1:5, ~ .x + 1)\n```\n\n`Python`:\n\n::: {#b4b04b6c .cell execution_count=1}\n``` {.python .cell-code}\nresult = list(map(lambda x: x + 1, range(1, 6)))\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n[2, 3, 4, 5, 6]\n```\n:::\n:::\n\n\n### `map2()`\n\n`R`:\n\n```R\nlibrary(purrr)\nmap2(1:5, 6:10, ~ .x + .y)\n```\n\n`Python`:\n\n::: {#f43c93c4 .cell execution_count=2}\n``` {.python .cell-code}\n# Using map with zip\nresult = list(map(lambda x, y: x + y, range(1, 6), range(6, 11)))\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n[7, 9, 11, 13, 15]\n```\n:::\n:::\n\n\n### `pmap()`\n\n`R`:\n\n```R\nlibrary(purrr)\npmap(list(1:3, 4:6, 7:9), sum)\n```\n\n`Python`:\n\n::: {#a1b48b2f .cell execution_count=3}\n``` {.python .cell-code}\nfrom itertools import starmap\n\n# Using starmap with zip\nresult = list(starmap(lambda x, y, z: x + y + z, zip(range(1, 4), range(4, 7), range(7, 10))))\nresult\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n[12, 15, 18]\n```\n:::\n:::\n\n\n### `accumulate()`\n\n\n`R`:\n\n```R\nlibrary(purrr)\naccumulate(1:5, ~ .x + .y)\n```\n\n`Python`:\n\n::: {#dfafb879 .cell execution_count=4}\n``` {.python .cell-code}\nfrom itertools import accumulate\nimport operator\n\n# Using accumulate\nresult = list(accumulate(range(1, 6), operator.add))\nprint(result)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 3, 6, 10, 15]\n```\n:::\n:::\n\n\n### `reduce()`\n\n`R`: \n\n```R\nlibrary(purrr)\nreduce(1:5, ~ .x + .y)\n```\n\n`Python`:\n\n::: {#0cb85314 .cell execution_count=5}\n``` {.python .cell-code}\nfrom functools import reduce\n\n# Using reduce\nresult = reduce(lambda x, y: x + y, range(1, 6))\nprint(result)  # Output: 15\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n15\n```\n:::\n:::\n\n\n## List comprehension vs `map()`\n\nIn general, list comprehension is prefered, because\n\n1. Faster\n2. More Pythonic \n\n::: {#fd62114d .cell execution_count=6}\n``` {.python .cell-code}\nimport timeit\n\na = list(range(1, 100))\n\n# Measure time for list comprehension\ntime_list_comprehension = timeit.timeit('[x + x for x in a]', globals=globals(), number=1000000)\n\n# Measure time for map() with lambda\ntime_itertools_map = timeit.timeit('list(map(lambda x: x + x, a))', globals=globals(), number=1000000)\n```\n:::\n\n\n::: {#dd51bdd0 .cell execution_count=7}\n``` {.python .cell-code}\nprint(f\"List Comprehension: {time_list_comprehension} seconds\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList Comprehension: 0.9625627920031548 seconds\n```\n:::\n:::\n\n\n::: {#3581027b .cell execution_count=8}\n``` {.python .cell-code}\nprint(f\"itertools map: {time_itertools_map} seconds\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nitertools map: 2.9447722919867374 seconds\n```\n:::\n:::\n\n\n",
    "supporting": [
      "fun-prog_files"
    ],
    "filters": [],
    "includes": {}
  }
}