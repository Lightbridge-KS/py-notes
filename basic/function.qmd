---
title: "Functions"
---

```{r setup, include=FALSE}
library(here)
here::i_am("basic/function.qmd")
source(here("_common.R"))
```



## Define a Function

```{python}
def greet():
  """Greeeting"""
  print("Hello World")
```


```{python}
greet()
```

## Arguments

Terminology: `key` = `value`

- **Parameters** are like `key`
- **Arguments** are like `value` that supply to the parameters


```{python}
def greet(first, last):
  """Greeeting someone"""
  print(f"Hello {first} {last}")
  print("Welcome aboard!")

```

**Parameters** = `first`, `last`

```{python}
greet("Ada", "Lovelace")
```

```{python}
# Using Keyword args
greet(first = "Mary",last="John")
```

Default parameter must come after required parameter

```{python}
def increment(x, by = 1):
  return x + by


```

```{python}
increment(2)
increment(2, 2)
```


**Arguments** = "Ada", "Lovelace"

## Return

return a value with `return` statement

```{python}
def get_greet(name):
  return f"Hello {name}"

```


```{python}
print(get_greet("mom"))
```

By default function return `None`, if not provide return value.

```{python}
def myfun():
  print("Hi")

```

```{python}
print(myfun())
```

## xargs 

use `*args` to receives any number of arguments to the function.

```{python}
def multi(*numbers):
  return numbers

 
a = multi(1, 3)
a
type(a)
```

**xargs** is a **tuple**. Let's iterate over "tuple"

```{python}
def multi(*numbers):
  for number in numbers:
    print(number)

    
```

Must be positional argument only

```{python}
multi(1, 2, 3)
```

keyword args is not allowed

```{python}
multi(a = 1)
```


### Exercise

Let's multiply any input of numbers.

```{python}
def multiply(*numbers):
  total = 1
  for number in numbers:
    total *= number
  return(total)

```

```{python}
multiply(2, 3, 4)
```

Same logic using `R`

```{r multiply_r1}
multiply_r1 <- function(...) {
  
  numbers <- list(...)
  total <- 1
  for (number in numbers) {
    total <- total * number
  }
  total
}

multiply_r1(1, 2, 3)
```

Or using `R` functional programming by `base::Reduce()` or `purrr::reduce()`

```{r multiply_r2}
multiply_r2 <- function(...) Reduce(`*`, list(...))

multiply_r2(1, 2, 3)
```




## xxargs 

Use `**args` to capture any number of **keyword arguments**

```{python}
def save_user(**user):
  return user

```

```{python}
usr = save_user(id = 1, name = "mike")
usr
type(usr)
```

If supply positional arg will fail.

```{python}
save_user("mike")
```


